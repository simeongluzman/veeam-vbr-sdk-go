// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateAuthorizationCode request
	CreateAuthorizationCode(ctx context.Context, params *CreateAuthorizationCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTokenWithFormdataBody(ctx context.Context, params *CreateTokenParams, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportCredentialsWithBody request with any body
	ExportCredentialsWithBody(ctx context.Context, params *ExportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportCredentials(ctx context.Context, params *ExportCredentialsParams, body ExportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportCredentialsWithBody request with any body
	ImportCredentialsWithBody(ctx context.Context, params *ImportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportCredentials(ctx context.Context, params *ImportCredentialsParams, body ImportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportEncryptionPasswordsWithBody request with any body
	ExportEncryptionPasswordsWithBody(ctx context.Context, params *ExportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportEncryptionPasswords(ctx context.Context, params *ExportEncryptionPasswordsParams, body ExportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportEncryptionPasswordsWithBody request with any body
	ImportEncryptionPasswordsWithBody(ctx context.Context, params *ImportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportEncryptionPasswords(ctx context.Context, params *ImportEncryptionPasswordsParams, body ImportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportJobsWithBody request with any body
	ExportJobsWithBody(ctx context.Context, params *ExportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportJobs(ctx context.Context, params *ExportJobsParams, body ExportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportJobsWithBody request with any body
	ImportJobsWithBody(ctx context.Context, params *ImportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportJobs(ctx context.Context, params *ImportJobsParams, body ImportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportManagedServersWithBody request with any body
	ExportManagedServersWithBody(ctx context.Context, params *ExportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportManagedServers(ctx context.Context, params *ExportManagedServersParams, body ExportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportManagedServersWithBody request with any body
	ImportManagedServersWithBody(ctx context.Context, params *ImportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportManagedServers(ctx context.Context, params *ImportManagedServersParams, body ImportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportProxiesWithBody request with any body
	ExportProxiesWithBody(ctx context.Context, params *ExportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportProxies(ctx context.Context, params *ExportProxiesParams, body ExportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportProxiesWithBody request with any body
	ImportProxiesWithBody(ctx context.Context, params *ImportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportProxies(ctx context.Context, params *ImportProxiesParams, body ImportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportRepositoriesWithBody request with any body
	ExportRepositoriesWithBody(ctx context.Context, params *ExportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportRepositories(ctx context.Context, params *ExportRepositoriesParams, body ExportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportRepositoriesWithBody request with any body
	ImportRepositoriesWithBody(ctx context.Context, params *ImportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportRepositories(ctx context.Context, params *ImportRepositoriesParams, body ImportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAutomationSessions request
	GetAllAutomationSessions(ctx context.Context, params *GetAllAutomationSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomationSession request
	GetAutomationSession(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomationSessionLogs request
	GetAutomationSessionLogs(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopAutomationSession request
	StopAutomationSession(ctx context.Context, id openapi_types.UUID, params *StopAutomationSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllManagedServers request
	GetAllManagedServers(ctx context.Context, params *GetAllManagedServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateManagedServerWithBody request with any body
	CreateManagedServerWithBody(ctx context.Context, params *CreateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateManagedServer(ctx context.Context, params *CreateManagedServerParams, body CreateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteManagedServer request
	DeleteManagedServer(ctx context.Context, id openapi_types.UUID, params *DeleteManagedServerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManagedServer request
	GetManagedServer(ctx context.Context, id openapi_types.UUID, params *GetManagedServerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateManagedServerWithBody request with any body
	UpdateManagedServerWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateManagedServer(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, body UpdateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllProxies request
	GetAllProxies(ctx context.Context, params *GetAllProxiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProxyWithBody request with any body
	CreateProxyWithBody(ctx context.Context, params *CreateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProxy(ctx context.Context, params *CreateProxyParams, body CreateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProxy request
	DeleteProxy(ctx context.Context, id openapi_types.UUID, params *DeleteProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProxy request
	GetProxy(ctx context.Context, id openapi_types.UUID, params *GetProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProxyWithBody request with any body
	UpdateProxyWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProxy(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, body UpdateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRepositories request
	GetAllRepositories(ctx context.Context, params *GetAllRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRepositoryWithBody request with any body
	CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRepositoriesStates request
	GetAllRepositoriesStates(ctx context.Context, params *GetAllRepositoriesStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepository request
	DeleteRepository(ctx context.Context, id openapi_types.UUID, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepository request
	GetRepository(ctx context.Context, id openapi_types.UUID, params *GetRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRepositoryWithBody request with any body
	UpdateRepositoryWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRepository(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllScaleOutRepositories request
	GetAllScaleOutRepositories(ctx context.Context, params *GetAllScaleOutRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScaleOutRepository request
	GetScaleOutRepository(ctx context.Context, id openapi_types.UUID, params *GetScaleOutRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableScaleOutExtentMaintenanceModeWithBody request with any body
	DisableScaleOutExtentMaintenanceModeWithBody(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableScaleOutExtentMaintenanceMode(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, body DisableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableScaleOutExtentMaintenanceModeWithBody request with any body
	EnableScaleOutExtentMaintenanceModeWithBody(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableScaleOutExtentMaintenanceMode(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, body EnableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBackupObjects request
	GetAllBackupObjects(ctx context.Context, params *GetAllBackupObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupObject request
	GetBackupObject(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupObjectRestorePoints request
	GetBackupObjectRestorePoints(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBackups request
	GetAllBackups(ctx context.Context, params *GetAllBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackup request
	GetBackup(ctx context.Context, id openapi_types.UUID, params *GetBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackupObjects request
	GetBackupObjects(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigBackupOptions request
	GetConfigBackupOptions(ctx context.Context, params *GetConfigBackupOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfigBackupOptionsWithBody request with any body
	UpdateConfigBackupOptionsWithBody(ctx context.Context, params *UpdateConfigBackupOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfigBackupOptions(ctx context.Context, params *UpdateConfigBackupOptionsParams, body UpdateConfigBackupOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartConfigBackup request
	StartConfigBackup(ctx context.Context, params *StartConfigBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectionCertificateWithBody request with any body
	GetConnectionCertificateWithBody(ctx context.Context, params *GetConnectionCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetConnectionCertificate(ctx context.Context, params *GetConnectionCertificateParams, body GetConnectionCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCreds request
	GetAllCreds(ctx context.Context, params *GetAllCredsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCredsWithBody request with any body
	CreateCredsWithBody(ctx context.Context, params *CreateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCreds(ctx context.Context, params *CreateCredsParams, body CreateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCreds request
	DeleteCreds(ctx context.Context, id openapi_types.UUID, params *DeleteCredsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCreds request
	GetCreds(ctx context.Context, id openapi_types.UUID, params *GetCredsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCredsWithBody request with any body
	UpdateCredsWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCreds(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, body UpdateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePasswordForCredsWithBody request with any body
	ChangePasswordForCredsWithBody(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePasswordForCreds(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, body ChangePasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePrivateKeyForCredsWithBody request with any body
	ChangePrivateKeyForCredsWithBody(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePrivateKeyForCreds(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, body ChangePrivateKeyForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeRootPasswordForCredsWithBody request with any body
	ChangeRootPasswordForCredsWithBody(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeRootPasswordForCreds(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, body ChangeRootPasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllEncryptionPasswords request
	GetAllEncryptionPasswords(ctx context.Context, params *GetAllEncryptionPasswordsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEncryptionPasswordWithBody request with any body
	CreateEncryptionPasswordWithBody(ctx context.Context, params *CreateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEncryptionPassword(ctx context.Context, params *CreateEncryptionPasswordParams, body CreateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEncryptionPassword request
	DeleteEncryptionPassword(ctx context.Context, id openapi_types.UUID, params *DeleteEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEncryptionPassword request
	GetEncryptionPassword(ctx context.Context, id openapi_types.UUID, params *GetEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEncryptionPasswordWithBody request with any body
	UpdateEncryptionPasswordWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEncryptionPassword(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, body UpdateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGeneralOptions request
	GetGeneralOptions(ctx context.Context, params *GetGeneralOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGeneralOptionsWithBody request with any body
	UpdateGeneralOptionsWithBody(ctx context.Context, params *UpdateGeneralOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGeneralOptions(ctx context.Context, params *UpdateGeneralOptionsParams, body UpdateGeneralOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllInventoryVmwareHosts request
	GetAllInventoryVmwareHosts(ctx context.Context, params *GetAllInventoryVmwareHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVmwareHostObject request
	GetVmwareHostObject(ctx context.Context, name string, params *GetVmwareHostObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllJobs request
	GetAllJobs(ctx context.Context, params *GetAllJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJobWithBody request with any body
	CreateJobWithBody(ctx context.Context, params *CreateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJob(ctx context.Context, params *CreateJobParams, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllJobsStates request
	GetAllJobsStates(ctx context.Context, params *GetAllJobsStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJob request
	DeleteJob(ctx context.Context, id openapi_types.UUID, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, id openapi_types.UUID, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJobWithBody request with any body
	UpdateJobWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJob(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableJob request
	DisableJob(ctx context.Context, id openapi_types.UUID, params *DisableJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableJob request
	EnableJob(ctx context.Context, id openapi_types.UUID, params *EnableJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartJobWithBody request with any body
	StartJobWithBody(ctx context.Context, id openapi_types.UUID, params *StartJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartJob(ctx context.Context, id openapi_types.UUID, params *StartJobParams, body StartJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopJobWithBody request with any body
	StopJobWithBody(ctx context.Context, id openapi_types.UUID, params *StopJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StopJob(ctx context.Context, id openapi_types.UUID, params *StopJobParams, body StopJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllObjectRestorePoints request
	GetAllObjectRestorePoints(ctx context.Context, params *GetAllObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectRestorePoint request
	GetObjectRestorePoint(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectRestorePointDisks request
	GetObjectRestorePointDisks(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointDisksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstantRecoveryVmwareFcdMountWithBody request with any body
	InstantRecoveryVmwareFcdMountWithBody(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstantRecoveryVmwareFcdMount(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, body InstantRecoveryVmwareFcdMountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVmwareFcdInstantRecoveryMountModel request
	GetVmwareFcdInstantRecoveryMountModel(ctx context.Context, mountId openapi_types.UUID, params *GetVmwareFcdInstantRecoveryMountModelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstantRecoveryVmwareFcdDismount request
	InstantRecoveryVmwareFcdDismount(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdDismountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstantRecoveryVmwareFcdMigrateWithBody request with any body
	InstantRecoveryVmwareFcdMigrateWithBody(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstantRecoveryVmwareFcdMigrate(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, body InstantRecoveryVmwareFcdMigrateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerCertificate request
	GetServerCertificate(ctx context.Context, params *GetServerCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTime request
	GetServerTime(ctx context.Context, params *GetServerTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServices request
	GetAllServices(ctx context.Context, params *GetAllServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSessions request
	GetAllSessions(ctx context.Context, params *GetAllSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSession request
	GetSession(ctx context.Context, id openapi_types.UUID, params *GetSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionLogs request
	GetSessionLogs(ctx context.Context, id openapi_types.UUID, params *GetSessionLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopSession request
	StopSession(ctx context.Context, id openapi_types.UUID, params *StopSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTrafficRules request
	GetAllTrafficRules(ctx context.Context, params *GetAllTrafficRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTrafficRulesWithBody request with any body
	UpdateTrafficRulesWithBody(ctx context.Context, params *UpdateTrafficRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTrafficRules(ctx context.Context, params *UpdateTrafficRulesParams, body UpdateTrafficRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateAuthorizationCode(ctx context.Context, params *CreateAuthorizationCodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAuthorizationCodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithFormdataBody(ctx context.Context, params *CreateTokenParams, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportCredentialsWithBody(ctx context.Context, params *ExportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportCredentialsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportCredentials(ctx context.Context, params *ExportCredentialsParams, body ExportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportCredentialsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCredentialsWithBody(ctx context.Context, params *ImportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCredentialsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCredentials(ctx context.Context, params *ImportCredentialsParams, body ImportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCredentialsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportEncryptionPasswordsWithBody(ctx context.Context, params *ExportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEncryptionPasswordsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportEncryptionPasswords(ctx context.Context, params *ExportEncryptionPasswordsParams, body ExportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportEncryptionPasswordsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportEncryptionPasswordsWithBody(ctx context.Context, params *ImportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEncryptionPasswordsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportEncryptionPasswords(ctx context.Context, params *ImportEncryptionPasswordsParams, body ImportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportEncryptionPasswordsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportJobsWithBody(ctx context.Context, params *ExportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportJobsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportJobs(ctx context.Context, params *ExportJobsParams, body ExportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportJobsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportJobsWithBody(ctx context.Context, params *ImportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportJobsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportJobs(ctx context.Context, params *ImportJobsParams, body ImportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportJobsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportManagedServersWithBody(ctx context.Context, params *ExportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportManagedServersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportManagedServers(ctx context.Context, params *ExportManagedServersParams, body ExportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportManagedServersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportManagedServersWithBody(ctx context.Context, params *ImportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportManagedServersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportManagedServers(ctx context.Context, params *ImportManagedServersParams, body ImportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportManagedServersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportProxiesWithBody(ctx context.Context, params *ExportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportProxiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportProxies(ctx context.Context, params *ExportProxiesParams, body ExportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportProxiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportProxiesWithBody(ctx context.Context, params *ImportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportProxiesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportProxies(ctx context.Context, params *ImportProxiesParams, body ImportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportProxiesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportRepositoriesWithBody(ctx context.Context, params *ExportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportRepositoriesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportRepositories(ctx context.Context, params *ExportRepositoriesParams, body ExportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportRepositoriesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportRepositoriesWithBody(ctx context.Context, params *ImportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportRepositoriesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportRepositories(ctx context.Context, params *ImportRepositoriesParams, body ImportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportRepositoriesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAutomationSessions(ctx context.Context, params *GetAllAutomationSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAutomationSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomationSession(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomationSessionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomationSessionLogs(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomationSessionLogsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopAutomationSession(ctx context.Context, id openapi_types.UUID, params *StopAutomationSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopAutomationSessionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllManagedServers(ctx context.Context, params *GetAllManagedServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllManagedServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManagedServerWithBody(ctx context.Context, params *CreateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagedServerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManagedServer(ctx context.Context, params *CreateManagedServerParams, body CreateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagedServerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManagedServer(ctx context.Context, id openapi_types.UUID, params *DeleteManagedServerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManagedServerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManagedServer(ctx context.Context, id openapi_types.UUID, params *GetManagedServerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManagedServerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManagedServerWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManagedServerRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateManagedServer(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, body UpdateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateManagedServerRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllProxies(ctx context.Context, params *GetAllProxiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllProxiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProxyWithBody(ctx context.Context, params *CreateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProxyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProxy(ctx context.Context, params *CreateProxyParams, body CreateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProxyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProxy(ctx context.Context, id openapi_types.UUID, params *DeleteProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProxyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProxy(ctx context.Context, id openapi_types.UUID, params *GetProxyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProxyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProxyWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProxyRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProxy(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, body UpdateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProxyRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRepositories(ctx context.Context, params *GetAllRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRepositoriesStates(ctx context.Context, params *GetAllRepositoriesStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRepositoriesStatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepository(ctx context.Context, id openapi_types.UUID, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepository(ctx context.Context, id openapi_types.UUID, params *GetRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRepositoryWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRepositoryRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRepository(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRepositoryRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllScaleOutRepositories(ctx context.Context, params *GetAllScaleOutRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllScaleOutRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScaleOutRepository(ctx context.Context, id openapi_types.UUID, params *GetScaleOutRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScaleOutRepositoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableScaleOutExtentMaintenanceModeWithBody(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableScaleOutExtentMaintenanceModeRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableScaleOutExtentMaintenanceMode(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, body DisableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableScaleOutExtentMaintenanceModeRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableScaleOutExtentMaintenanceModeWithBody(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableScaleOutExtentMaintenanceModeRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableScaleOutExtentMaintenanceMode(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, body EnableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableScaleOutExtentMaintenanceModeRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBackupObjects(ctx context.Context, params *GetAllBackupObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBackupObjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupObject(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupObjectRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupObjectRestorePoints(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupObjectRestorePointsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBackups(ctx context.Context, params *GetAllBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBackupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackup(ctx context.Context, id openapi_types.UUID, params *GetBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackupObjects(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupObjectsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigBackupOptions(ctx context.Context, params *GetConfigBackupOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigBackupOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigBackupOptionsWithBody(ctx context.Context, params *UpdateConfigBackupOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigBackupOptionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigBackupOptions(ctx context.Context, params *UpdateConfigBackupOptionsParams, body UpdateConfigBackupOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigBackupOptionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartConfigBackup(ctx context.Context, params *StartConfigBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartConfigBackupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectionCertificateWithBody(ctx context.Context, params *GetConnectionCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionCertificateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectionCertificate(ctx context.Context, params *GetConnectionCertificateParams, body GetConnectionCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectionCertificateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCreds(ctx context.Context, params *GetAllCredsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCredsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCredsWithBody(ctx context.Context, params *CreateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCreds(ctx context.Context, params *CreateCredsParams, body CreateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCreds(ctx context.Context, id openapi_types.UUID, params *DeleteCredsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCreds(ctx context.Context, id openapi_types.UUID, params *GetCredsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCredsWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCredsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCreds(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, body UpdateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCredsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePasswordForCredsWithBody(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordForCredsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePasswordForCreds(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, body ChangePasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordForCredsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePrivateKeyForCredsWithBody(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePrivateKeyForCredsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePrivateKeyForCreds(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, body ChangePrivateKeyForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePrivateKeyForCredsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeRootPasswordForCredsWithBody(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeRootPasswordForCredsRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeRootPasswordForCreds(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, body ChangeRootPasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeRootPasswordForCredsRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllEncryptionPasswords(ctx context.Context, params *GetAllEncryptionPasswordsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllEncryptionPasswordsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEncryptionPasswordWithBody(ctx context.Context, params *CreateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEncryptionPasswordRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEncryptionPassword(ctx context.Context, params *CreateEncryptionPasswordParams, body CreateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEncryptionPasswordRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEncryptionPassword(ctx context.Context, id openapi_types.UUID, params *DeleteEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEncryptionPasswordRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEncryptionPassword(ctx context.Context, id openapi_types.UUID, params *GetEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEncryptionPasswordRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEncryptionPasswordWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEncryptionPasswordRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEncryptionPassword(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, body UpdateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEncryptionPasswordRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGeneralOptions(ctx context.Context, params *GetGeneralOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGeneralOptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGeneralOptionsWithBody(ctx context.Context, params *UpdateGeneralOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGeneralOptionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGeneralOptions(ctx context.Context, params *UpdateGeneralOptionsParams, body UpdateGeneralOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGeneralOptionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllInventoryVmwareHosts(ctx context.Context, params *GetAllInventoryVmwareHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllInventoryVmwareHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVmwareHostObject(ctx context.Context, name string, params *GetVmwareHostObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmwareHostObjectRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllJobs(ctx context.Context, params *GetAllJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJobWithBody(ctx context.Context, params *CreateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJob(ctx context.Context, params *CreateJobParams, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJobRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllJobsStates(ctx context.Context, params *GetAllJobsStatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllJobsStatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJob(ctx context.Context, id openapi_types.UUID, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, id openapi_types.UUID, params *GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJobWithBody(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJob(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJobRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableJob(ctx context.Context, id openapi_types.UUID, params *DisableJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableJobRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableJob(ctx context.Context, id openapi_types.UUID, params *EnableJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableJobRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartJobWithBody(ctx context.Context, id openapi_types.UUID, params *StartJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartJobRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartJob(ctx context.Context, id openapi_types.UUID, params *StartJobParams, body StartJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartJobRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopJobWithBody(ctx context.Context, id openapi_types.UUID, params *StopJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopJobRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopJob(ctx context.Context, id openapi_types.UUID, params *StopJobParams, body StopJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopJobRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllObjectRestorePoints(ctx context.Context, params *GetAllObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllObjectRestorePointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectRestorePoint(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRestorePointRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectRestorePointDisks(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointDisksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRestorePointDisksRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstantRecoveryVmwareFcdMountWithBody(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstantRecoveryVmwareFcdMountRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstantRecoveryVmwareFcdMount(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, body InstantRecoveryVmwareFcdMountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstantRecoveryVmwareFcdMountRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVmwareFcdInstantRecoveryMountModel(ctx context.Context, mountId openapi_types.UUID, params *GetVmwareFcdInstantRecoveryMountModelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVmwareFcdInstantRecoveryMountModelRequest(c.Server, mountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstantRecoveryVmwareFcdDismount(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdDismountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstantRecoveryVmwareFcdDismountRequest(c.Server, mountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstantRecoveryVmwareFcdMigrateWithBody(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstantRecoveryVmwareFcdMigrateRequestWithBody(c.Server, mountId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstantRecoveryVmwareFcdMigrate(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, body InstantRecoveryVmwareFcdMigrateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstantRecoveryVmwareFcdMigrateRequest(c.Server, mountId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerCertificate(ctx context.Context, params *GetServerCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerCertificateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTime(ctx context.Context, params *GetServerTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTimeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServices(ctx context.Context, params *GetAllServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSessions(ctx context.Context, params *GetAllSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSession(ctx context.Context, id openapi_types.UUID, params *GetSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionLogs(ctx context.Context, id openapi_types.UUID, params *GetSessionLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionLogsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopSession(ctx context.Context, id openapi_types.UUID, params *StopSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopSessionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTrafficRules(ctx context.Context, params *GetAllTrafficRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTrafficRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTrafficRulesWithBody(ctx context.Context, params *UpdateTrafficRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTrafficRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTrafficRules(ctx context.Context, params *UpdateTrafficRulesParams, body UpdateTrafficRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTrafficRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateAuthorizationCodeRequest generates requests for CreateAuthorizationCode
func NewCreateAuthorizationCodeRequest(server string, params *CreateAuthorizationCodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/oauth2/authorization_code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string, params *LogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/oauth2/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateTokenRequestWithFormdataBody calls the generic CreateToken builder with application/x-www-form-urlencoded body
func NewCreateTokenRequestWithFormdataBody(server string, params *CreateTokenParams, body CreateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewCreateTokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, params *CreateTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/oauth2/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewExportCredentialsRequest calls the generic ExportCredentials builder with application/json body
func NewExportCredentialsRequest(server string, params *ExportCredentialsParams, body ExportCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportCredentialsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExportCredentialsRequestWithBody generates requests for ExportCredentials with any type of body
func NewExportCredentialsRequestWithBody(server string, params *ExportCredentialsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/credentials/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewImportCredentialsRequest calls the generic ImportCredentials builder with application/json body
func NewImportCredentialsRequest(server string, params *ImportCredentialsParams, body ImportCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportCredentialsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportCredentialsRequestWithBody generates requests for ImportCredentials with any type of body
func NewImportCredentialsRequestWithBody(server string, params *ImportCredentialsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/credentials/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewExportEncryptionPasswordsRequest calls the generic ExportEncryptionPasswords builder with application/json body
func NewExportEncryptionPasswordsRequest(server string, params *ExportEncryptionPasswordsParams, body ExportEncryptionPasswordsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportEncryptionPasswordsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExportEncryptionPasswordsRequestWithBody generates requests for ExportEncryptionPasswords with any type of body
func NewExportEncryptionPasswordsRequestWithBody(server string, params *ExportEncryptionPasswordsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/encryptionPasswords/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewImportEncryptionPasswordsRequest calls the generic ImportEncryptionPasswords builder with application/json body
func NewImportEncryptionPasswordsRequest(server string, params *ImportEncryptionPasswordsParams, body ImportEncryptionPasswordsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportEncryptionPasswordsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportEncryptionPasswordsRequestWithBody generates requests for ImportEncryptionPasswords with any type of body
func NewImportEncryptionPasswordsRequestWithBody(server string, params *ImportEncryptionPasswordsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/encryptionPasswords/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewExportJobsRequest calls the generic ExportJobs builder with application/json body
func NewExportJobsRequest(server string, params *ExportJobsParams, body ExportJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportJobsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExportJobsRequestWithBody generates requests for ExportJobs with any type of body
func NewExportJobsRequestWithBody(server string, params *ExportJobsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/jobs/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewImportJobsRequest calls the generic ImportJobs builder with application/json body
func NewImportJobsRequest(server string, params *ImportJobsParams, body ImportJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportJobsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportJobsRequestWithBody generates requests for ImportJobs with any type of body
func NewImportJobsRequestWithBody(server string, params *ImportJobsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/jobs/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewExportManagedServersRequest calls the generic ExportManagedServers builder with application/json body
func NewExportManagedServersRequest(server string, params *ExportManagedServersParams, body ExportManagedServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportManagedServersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExportManagedServersRequestWithBody generates requests for ExportManagedServers with any type of body
func NewExportManagedServersRequestWithBody(server string, params *ExportManagedServersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/managedServers/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewImportManagedServersRequest calls the generic ImportManagedServers builder with application/json body
func NewImportManagedServersRequest(server string, params *ImportManagedServersParams, body ImportManagedServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportManagedServersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportManagedServersRequestWithBody generates requests for ImportManagedServers with any type of body
func NewImportManagedServersRequestWithBody(server string, params *ImportManagedServersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/managedServers/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewExportProxiesRequest calls the generic ExportProxies builder with application/json body
func NewExportProxiesRequest(server string, params *ExportProxiesParams, body ExportProxiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportProxiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExportProxiesRequestWithBody generates requests for ExportProxies with any type of body
func NewExportProxiesRequestWithBody(server string, params *ExportProxiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/proxies/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewImportProxiesRequest calls the generic ImportProxies builder with application/json body
func NewImportProxiesRequest(server string, params *ImportProxiesParams, body ImportProxiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportProxiesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportProxiesRequestWithBody generates requests for ImportProxies with any type of body
func NewImportProxiesRequestWithBody(server string, params *ImportProxiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/proxies/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewExportRepositoriesRequest calls the generic ExportRepositories builder with application/json body
func NewExportRepositoriesRequest(server string, params *ExportRepositoriesParams, body ExportRepositoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportRepositoriesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewExportRepositoriesRequestWithBody generates requests for ExportRepositories with any type of body
func NewExportRepositoriesRequestWithBody(server string, params *ExportRepositoriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/repositories/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewImportRepositoriesRequest calls the generic ImportRepositories builder with application/json body
func NewImportRepositoriesRequest(server string, params *ImportRepositoriesParams, body ImportRepositoriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportRepositoriesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewImportRepositoriesRequestWithBody generates requests for ImportRepositories with any type of body
func NewImportRepositoriesRequestWithBody(server string, params *ImportRepositoriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/repositories/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllAutomationSessionsRequest generates requests for GetAllAutomationSessions
func NewGetAllAutomationSessionsRequest(server string, params *GetAllAutomationSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfterFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfterFilter", runtime.ParamLocationQuery, *params.CreatedAfterFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBeforeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBeforeFilter", runtime.ParamLocationQuery, *params.CreatedBeforeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAfterFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endedAfterFilter", runtime.ParamLocationQuery, *params.EndedAfterFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedBeforeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endedBeforeFilter", runtime.ParamLocationQuery, *params.EndedBeforeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResultFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resultFilter", runtime.ParamLocationQuery, *params.ResultFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobIdFilter", runtime.ParamLocationQuery, *params.JobIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAutomationSessionRequest generates requests for GetAutomationSession
func NewGetAutomationSessionRequest(server string, id openapi_types.UUID, params *GetAutomationSessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAutomationSessionLogsRequest generates requests for GetAutomationSessionLogs
func NewGetAutomationSessionLogsRequest(server string, id openapi_types.UUID, params *GetAutomationSessionLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/sessions/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewStopAutomationSessionRequest generates requests for StopAutomationSession
func NewStopAutomationSessionRequest(server string, id openapi_types.UUID, params *StopAutomationSessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/automation/sessions/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllManagedServersRequest generates requests for GetAllManagedServers
func NewGetAllManagedServersRequest(server string, params *GetAllManagedServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/managedServers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ViTypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "viTypeFilter", runtime.ParamLocationQuery, *params.ViTypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateManagedServerRequest calls the generic CreateManagedServer builder with application/json body
func NewCreateManagedServerRequest(server string, params *CreateManagedServerParams, body CreateManagedServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManagedServerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateManagedServerRequestWithBody generates requests for CreateManagedServer with any type of body
func NewCreateManagedServerRequestWithBody(server string, params *CreateManagedServerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/managedServers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDeleteManagedServerRequest generates requests for DeleteManagedServer
func NewDeleteManagedServerRequest(server string, id openapi_types.UUID, params *DeleteManagedServerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/managedServers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetManagedServerRequest generates requests for GetManagedServer
func NewGetManagedServerRequest(server string, id openapi_types.UUID, params *GetManagedServerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/managedServers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateManagedServerRequest calls the generic UpdateManagedServer builder with application/json body
func NewUpdateManagedServerRequest(server string, id openapi_types.UUID, params *UpdateManagedServerParams, body UpdateManagedServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateManagedServerRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateManagedServerRequestWithBody generates requests for UpdateManagedServer with any type of body
func NewUpdateManagedServerRequestWithBody(server string, id openapi_types.UUID, params *UpdateManagedServerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/managedServers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllProxiesRequest generates requests for GetAllProxies
func NewGetAllProxiesRequest(server string, params *GetAllProxiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/proxies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HostIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostIdFilter", runtime.ParamLocationQuery, *params.HostIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateProxyRequest calls the generic CreateProxy builder with application/json body
func NewCreateProxyRequest(server string, params *CreateProxyParams, body CreateProxyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProxyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateProxyRequestWithBody generates requests for CreateProxy with any type of body
func NewCreateProxyRequestWithBody(server string, params *CreateProxyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/proxies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDeleteProxyRequest generates requests for DeleteProxy
func NewDeleteProxyRequest(server string, id openapi_types.UUID, params *DeleteProxyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/proxies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetProxyRequest generates requests for GetProxy
func NewGetProxyRequest(server string, id openapi_types.UUID, params *GetProxyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/proxies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateProxyRequest calls the generic UpdateProxy builder with application/json body
func NewUpdateProxyRequest(server string, id openapi_types.UUID, params *UpdateProxyParams, body UpdateProxyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProxyRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateProxyRequestWithBody generates requests for UpdateProxy with any type of body
func NewUpdateProxyRequestWithBody(server string, id openapi_types.UUID, params *UpdateProxyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/proxies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllRepositoriesRequest generates requests for GetAllRepositories
func NewGetAllRepositoriesRequest(server string, params *GetAllRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HostIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hostIdFilter", runtime.ParamLocationQuery, *params.HostIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PathFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pathFilter", runtime.ParamLocationQuery, *params.PathFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VmbApiFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vmbApiFilter", runtime.ParamLocationQuery, *params.VmbApiFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateRepositoryRequest calls the generic CreateRepository builder with application/json body
func NewCreateRepositoryRequest(server string, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRepositoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRepositoryRequestWithBody generates requests for CreateRepository with any type of body
func NewCreateRepositoryRequestWithBody(server string, params *CreateRepositoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllRepositoriesStatesRequest generates requests for GetAllRepositoriesStates
func NewGetAllRepositoriesStatesRequest(server string, params *GetAllRepositoriesStatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/repositories/states")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idFilter", runtime.ParamLocationQuery, *params.IdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CapacityFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "capacityFilter", runtime.ParamLocationQuery, *params.CapacityFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FreeSpaceFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "freeSpaceFilter", runtime.ParamLocationQuery, *params.FreeSpaceFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsedSpaceFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "usedSpaceFilter", runtime.ParamLocationQuery, *params.UsedSpaceFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDeleteRepositoryRequest generates requests for DeleteRepository
func NewDeleteRepositoryRequest(server string, id openapi_types.UUID, params *DeleteRepositoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteBackups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deleteBackups", runtime.ParamLocationQuery, *params.DeleteBackups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetRepositoryRequest generates requests for GetRepository
func NewGetRepositoryRequest(server string, id openapi_types.UUID, params *GetRepositoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateRepositoryRequest calls the generic UpdateRepository builder with application/json body
func NewUpdateRepositoryRequest(server string, id openapi_types.UUID, params *UpdateRepositoryParams, body UpdateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRepositoryRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateRepositoryRequestWithBody generates requests for UpdateRepository with any type of body
func NewUpdateRepositoryRequestWithBody(server string, id openapi_types.UUID, params *UpdateRepositoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllScaleOutRepositoriesRequest generates requests for GetAllScaleOutRepositories
func NewGetAllScaleOutRepositoriesRequest(server string, params *GetAllScaleOutRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/scaleOutRepositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetScaleOutRepositoryRequest generates requests for GetScaleOutRepository
func NewGetScaleOutRepositoryRequest(server string, id openapi_types.UUID, params *GetScaleOutRepositoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/scaleOutRepositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDisableScaleOutExtentMaintenanceModeRequest calls the generic DisableScaleOutExtentMaintenanceMode builder with application/json body
func NewDisableScaleOutExtentMaintenanceModeRequest(server string, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, body DisableScaleOutExtentMaintenanceModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableScaleOutExtentMaintenanceModeRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewDisableScaleOutExtentMaintenanceModeRequestWithBody generates requests for DisableScaleOutExtentMaintenanceMode with any type of body
func NewDisableScaleOutExtentMaintenanceModeRequestWithBody(server string, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/scaleOutRepositories/%s/disableMaintenanceMode", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewEnableScaleOutExtentMaintenanceModeRequest calls the generic EnableScaleOutExtentMaintenanceMode builder with application/json body
func NewEnableScaleOutExtentMaintenanceModeRequest(server string, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, body EnableScaleOutExtentMaintenanceModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableScaleOutExtentMaintenanceModeRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewEnableScaleOutExtentMaintenanceModeRequestWithBody generates requests for EnableScaleOutExtentMaintenanceMode with any type of body
func NewEnableScaleOutExtentMaintenanceModeRequestWithBody(server string, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupInfrastructure/scaleOutRepositories/%s/enableMaintenanceMode", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllBackupObjectsRequest generates requests for GetAllBackupObjects
func NewGetAllBackupObjectsRequest(server string, params *GetAllBackupObjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupObjects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformNameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platformNameFilter", runtime.ParamLocationQuery, *params.PlatformNameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platformIdFilter", runtime.ParamLocationQuery, *params.PlatformIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ViTypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "viTypeFilter", runtime.ParamLocationQuery, *params.ViTypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetBackupObjectRequest generates requests for GetBackupObject
func NewGetBackupObjectRequest(server string, id openapi_types.UUID, params *GetBackupObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupObjects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetBackupObjectRestorePointsRequest generates requests for GetBackupObjectRestorePoints
func NewGetBackupObjectRestorePointsRequest(server string, id openapi_types.UUID, params *GetBackupObjectRestorePointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backupObjects/%s/restorePoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllBackupsRequest generates requests for GetAllBackups
func NewGetAllBackupsRequest(server string, params *GetAllBackupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfterFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfterFilter", runtime.ParamLocationQuery, *params.CreatedAfterFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBeforeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBeforeFilter", runtime.ParamLocationQuery, *params.CreatedBeforeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platformIdFilter", runtime.ParamLocationQuery, *params.PlatformIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobIdFilter", runtime.ParamLocationQuery, *params.JobIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyTagFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policyTagFilter", runtime.ParamLocationQuery, *params.PolicyTagFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetBackupRequest generates requests for GetBackup
func NewGetBackupRequest(server string, id openapi_types.UUID, params *GetBackupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetBackupObjectsRequest generates requests for GetBackupObjects
func NewGetBackupObjectsRequest(server string, id openapi_types.UUID, params *GetBackupObjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/backups/%s/objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetConfigBackupOptionsRequest generates requests for GetConfigBackupOptions
func NewGetConfigBackupOptionsRequest(server string, params *GetConfigBackupOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/configBackup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateConfigBackupOptionsRequest calls the generic UpdateConfigBackupOptions builder with application/json body
func NewUpdateConfigBackupOptionsRequest(server string, params *UpdateConfigBackupOptionsParams, body UpdateConfigBackupOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigBackupOptionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateConfigBackupOptionsRequestWithBody generates requests for UpdateConfigBackupOptions with any type of body
func NewUpdateConfigBackupOptionsRequestWithBody(server string, params *UpdateConfigBackupOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/configBackup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewStartConfigBackupRequest generates requests for StartConfigBackup
func NewStartConfigBackupRequest(server string, params *StartConfigBackupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/configBackup/backup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetConnectionCertificateRequest calls the generic GetConnectionCertificate builder with application/json body
func NewGetConnectionCertificateRequest(server string, params *GetConnectionCertificateParams, body GetConnectionCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetConnectionCertificateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetConnectionCertificateRequestWithBody generates requests for GetConnectionCertificate with any type of body
func NewGetConnectionCertificateRequestWithBody(server string, params *GetConnectionCertificateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/connectionCertificate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllCredsRequest generates requests for GetAllCreds
func NewGetAllCredsRequest(server string, params *GetAllCredsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateCredsRequest calls the generic CreateCreds builder with application/json body
func NewCreateCredsRequest(server string, params *CreateCredsParams, body CreateCredsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCredsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCredsRequestWithBody generates requests for CreateCreds with any type of body
func NewCreateCredsRequestWithBody(server string, params *CreateCredsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDeleteCredsRequest generates requests for DeleteCreds
func NewDeleteCredsRequest(server string, id openapi_types.UUID, params *DeleteCredsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetCredsRequest generates requests for GetCreds
func NewGetCredsRequest(server string, id openapi_types.UUID, params *GetCredsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateCredsRequest calls the generic UpdateCreds builder with application/json body
func NewUpdateCredsRequest(server string, id openapi_types.UUID, params *UpdateCredsParams, body UpdateCredsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCredsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateCredsRequestWithBody generates requests for UpdateCreds with any type of body
func NewUpdateCredsRequestWithBody(server string, id openapi_types.UUID, params *UpdateCredsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewChangePasswordForCredsRequest calls the generic ChangePasswordForCreds builder with application/json body
func NewChangePasswordForCredsRequest(server string, id openapi_types.UUID, params *ChangePasswordForCredsParams, body ChangePasswordForCredsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePasswordForCredsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewChangePasswordForCredsRequestWithBody generates requests for ChangePasswordForCreds with any type of body
func NewChangePasswordForCredsRequestWithBody(server string, id openapi_types.UUID, params *ChangePasswordForCredsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials/%s/changepassword", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewChangePrivateKeyForCredsRequest calls the generic ChangePrivateKeyForCreds builder with application/json body
func NewChangePrivateKeyForCredsRequest(server string, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, body ChangePrivateKeyForCredsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePrivateKeyForCredsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewChangePrivateKeyForCredsRequestWithBody generates requests for ChangePrivateKeyForCreds with any type of body
func NewChangePrivateKeyForCredsRequestWithBody(server string, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials/%s/changeprivatekey", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewChangeRootPasswordForCredsRequest calls the generic ChangeRootPasswordForCreds builder with application/json body
func NewChangeRootPasswordForCredsRequest(server string, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, body ChangeRootPasswordForCredsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeRootPasswordForCredsRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewChangeRootPasswordForCredsRequestWithBody generates requests for ChangeRootPasswordForCreds with any type of body
func NewChangeRootPasswordForCredsRequestWithBody(server string, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/credentials/%s/changerootpassword", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllEncryptionPasswordsRequest generates requests for GetAllEncryptionPasswords
func NewGetAllEncryptionPasswordsRequest(server string, params *GetAllEncryptionPasswordsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/encryptionPasswords")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateEncryptionPasswordRequest calls the generic CreateEncryptionPassword builder with application/json body
func NewCreateEncryptionPasswordRequest(server string, params *CreateEncryptionPasswordParams, body CreateEncryptionPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEncryptionPasswordRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateEncryptionPasswordRequestWithBody generates requests for CreateEncryptionPassword with any type of body
func NewCreateEncryptionPasswordRequestWithBody(server string, params *CreateEncryptionPasswordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/encryptionPasswords")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDeleteEncryptionPasswordRequest generates requests for DeleteEncryptionPassword
func NewDeleteEncryptionPasswordRequest(server string, id openapi_types.UUID, params *DeleteEncryptionPasswordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/encryptionPasswords/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetEncryptionPasswordRequest generates requests for GetEncryptionPassword
func NewGetEncryptionPasswordRequest(server string, id openapi_types.UUID, params *GetEncryptionPasswordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/encryptionPasswords/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateEncryptionPasswordRequest calls the generic UpdateEncryptionPassword builder with application/json body
func NewUpdateEncryptionPasswordRequest(server string, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, body UpdateEncryptionPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEncryptionPasswordRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateEncryptionPasswordRequestWithBody generates requests for UpdateEncryptionPassword with any type of body
func NewUpdateEncryptionPasswordRequestWithBody(server string, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/encryptionPasswords/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetGeneralOptionsRequest generates requests for GetGeneralOptions
func NewGetGeneralOptionsRequest(server string, params *GetGeneralOptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/generalOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateGeneralOptionsRequest calls the generic UpdateGeneralOptions builder with application/json body
func NewUpdateGeneralOptionsRequest(server string, params *UpdateGeneralOptionsParams, body UpdateGeneralOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGeneralOptionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateGeneralOptionsRequestWithBody generates requests for UpdateGeneralOptions with any type of body
func NewUpdateGeneralOptionsRequestWithBody(server string, params *UpdateGeneralOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/generalOptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllInventoryVmwareHostsRequest generates requests for GetAllInventoryVmwareHosts
func NewGetAllInventoryVmwareHostsRequest(server string, params *GetAllInventoryVmwareHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/inventory/vmware/hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetVmwareHostObjectRequest generates requests for GetVmwareHostObject
func NewGetVmwareHostObjectRequest(server string, name string, params *GetVmwareHostObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/inventory/vmware/hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectIdFilter", runtime.ParamLocationQuery, *params.ObjectIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HierarchyTypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hierarchyTypeFilter", runtime.ParamLocationQuery, *params.HierarchyTypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentContainerNameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentContainerNameFilter", runtime.ParamLocationQuery, *params.ParentContainerNameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllJobsRequest generates requests for GetAllJobs
func NewGetAllJobsRequest(server string, params *GetAllJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateJobRequest calls the generic CreateJob builder with application/json body
func NewCreateJobRequest(server string, params *CreateJobParams, body CreateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJobRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateJobRequestWithBody generates requests for CreateJob with any type of body
func NewCreateJobRequestWithBody(server string, params *CreateJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllJobsStatesRequest generates requests for GetAllJobsStates
func NewGetAllJobsStatesRequest(server string, params *GetAllJobsStatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/states")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "idFilter", runtime.ParamLocationQuery, *params.IdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastResultFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastResultFilter", runtime.ParamLocationQuery, *params.LastResultFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusFilter", runtime.ParamLocationQuery, *params.StatusFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkloadFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workloadFilter", runtime.ParamLocationQuery, *params.WorkloadFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastRunAfterFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastRunAfterFilter", runtime.ParamLocationQuery, *params.LastRunAfterFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastRunBeforeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lastRunBeforeFilter", runtime.ParamLocationQuery, *params.LastRunBeforeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsHighPriorityJobFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHighPriorityJobFilter", runtime.ParamLocationQuery, *params.IsHighPriorityJobFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RepositoryIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repositoryIdFilter", runtime.ParamLocationQuery, *params.RepositoryIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectsCountFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectsCountFilter", runtime.ParamLocationQuery, *params.ObjectsCountFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDeleteJobRequest generates requests for DeleteJob
func NewDeleteJobRequest(server string, id openapi_types.UUID, params *DeleteJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, id openapi_types.UUID, params *GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateJobRequest calls the generic UpdateJob builder with application/json body
func NewUpdateJobRequest(server string, id openapi_types.UUID, params *UpdateJobParams, body UpdateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJobRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateJobRequestWithBody generates requests for UpdateJob with any type of body
func NewUpdateJobRequestWithBody(server string, id openapi_types.UUID, params *UpdateJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewDisableJobRequest generates requests for DisableJob
func NewDisableJobRequest(server string, id openapi_types.UUID, params *DisableJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewEnableJobRequest generates requests for EnableJob
func NewEnableJobRequest(server string, id openapi_types.UUID, params *EnableJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewStartJobRequest calls the generic StartJob builder with application/json body
func NewStartJobRequest(server string, id openapi_types.UUID, params *StartJobParams, body StartJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartJobRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewStartJobRequestWithBody generates requests for StartJob with any type of body
func NewStartJobRequestWithBody(server string, id openapi_types.UUID, params *StartJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewStopJobRequest calls the generic StopJob builder with application/json body
func NewStopJobRequest(server string, id openapi_types.UUID, params *StopJobParams, body StopJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStopJobRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewStopJobRequestWithBody generates requests for StopJob with any type of body
func NewStopJobRequestWithBody(server string, id openapi_types.UUID, params *StopJobParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/jobs/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllObjectRestorePointsRequest generates requests for GetAllObjectRestorePoints
func NewGetAllObjectRestorePointsRequest(server string, params *GetAllObjectRestorePointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/objectRestorePoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfterFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfterFilter", runtime.ParamLocationQuery, *params.CreatedAfterFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBeforeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBeforeFilter", runtime.ParamLocationQuery, *params.CreatedBeforeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformNameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platformNameFilter", runtime.ParamLocationQuery, *params.PlatformNameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PlatformIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "platformIdFilter", runtime.ParamLocationQuery, *params.PlatformIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackupIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backupIdFilter", runtime.ParamLocationQuery, *params.BackupIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BackupObjectIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backupObjectIdFilter", runtime.ParamLocationQuery, *params.BackupObjectIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetObjectRestorePointRequest generates requests for GetObjectRestorePoint
func NewGetObjectRestorePointRequest(server string, id openapi_types.UUID, params *GetObjectRestorePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/objectRestorePoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetObjectRestorePointDisksRequest generates requests for GetObjectRestorePointDisks
func NewGetObjectRestorePointDisksRequest(server string, id openapi_types.UUID, params *GetObjectRestorePointDisksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/objectRestorePoints/%s/disks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewInstantRecoveryVmwareFcdMountRequest calls the generic InstantRecoveryVmwareFcdMount builder with application/json body
func NewInstantRecoveryVmwareFcdMountRequest(server string, params *InstantRecoveryVmwareFcdMountParams, body InstantRecoveryVmwareFcdMountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstantRecoveryVmwareFcdMountRequestWithBody(server, params, "application/json", bodyReader)
}

// NewInstantRecoveryVmwareFcdMountRequestWithBody generates requests for InstantRecoveryVmwareFcdMount with any type of body
func NewInstantRecoveryVmwareFcdMountRequestWithBody(server string, params *InstantRecoveryVmwareFcdMountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/restore/instantRecovery/vmware/fcd/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetVmwareFcdInstantRecoveryMountModelRequest generates requests for GetVmwareFcdInstantRecoveryMountModel
func NewGetVmwareFcdInstantRecoveryMountModelRequest(server string, mountId openapi_types.UUID, params *GetVmwareFcdInstantRecoveryMountModelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mountId", runtime.ParamLocationPath, mountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/restore/instantRecovery/vmware/fcd/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewInstantRecoveryVmwareFcdDismountRequest generates requests for InstantRecoveryVmwareFcdDismount
func NewInstantRecoveryVmwareFcdDismountRequest(server string, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdDismountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mountId", runtime.ParamLocationPath, mountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/restore/instantRecovery/vmware/fcd/%s/dismount", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewInstantRecoveryVmwareFcdMigrateRequest calls the generic InstantRecoveryVmwareFcdMigrate builder with application/json body
func NewInstantRecoveryVmwareFcdMigrateRequest(server string, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, body InstantRecoveryVmwareFcdMigrateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstantRecoveryVmwareFcdMigrateRequestWithBody(server, mountId, params, "application/json", bodyReader)
}

// NewInstantRecoveryVmwareFcdMigrateRequestWithBody generates requests for InstantRecoveryVmwareFcdMigrate with any type of body
func NewInstantRecoveryVmwareFcdMigrateRequestWithBody(server string, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mountId", runtime.ParamLocationPath, mountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/restore/instantRecovery/vmware/fcd/%s/migrate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetServerCertificateRequest generates requests for GetServerCertificate
func NewGetServerCertificateRequest(server string, params *GetServerCertificateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverCertificate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetServerTimeRequest generates requests for GetServerTime
func NewGetServerTimeRequest(server string, params *GetServerTimeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/serverTime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllServicesRequest generates requests for GetAllServices
func NewGetAllServicesRequest(server string, params *GetAllServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllSessionsRequest generates requests for GetAllSessions
func NewGetAllSessionsRequest(server string, params *GetAllSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderColumn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderColumn", runtime.ParamLocationQuery, *params.OrderColumn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderAsc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderAsc", runtime.ParamLocationQuery, *params.OrderAsc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameFilter", runtime.ParamLocationQuery, *params.NameFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfterFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAfterFilter", runtime.ParamLocationQuery, *params.CreatedAfterFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBeforeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdBeforeFilter", runtime.ParamLocationQuery, *params.CreatedBeforeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAfterFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endedAfterFilter", runtime.ParamLocationQuery, *params.EndedAfterFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedBeforeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endedBeforeFilter", runtime.ParamLocationQuery, *params.EndedBeforeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TypeFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "typeFilter", runtime.ParamLocationQuery, *params.TypeFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StateFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stateFilter", runtime.ParamLocationQuery, *params.StateFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResultFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resultFilter", runtime.ParamLocationQuery, *params.ResultFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobIdFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobIdFilter", runtime.ParamLocationQuery, *params.JobIdFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetSessionRequest generates requests for GetSession
func NewGetSessionRequest(server string, id openapi_types.UUID, params *GetSessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetSessionLogsRequest generates requests for GetSessionLogs
func NewGetSessionLogsRequest(server string, id openapi_types.UUID, params *GetSessionLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sessions/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewStopSessionRequest generates requests for StopSession
func NewStopSessionRequest(server string, id openapi_types.UUID, params *StopSessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sessions/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAllTrafficRulesRequest generates requests for GetAllTrafficRules
func NewGetAllTrafficRulesRequest(server string, params *GetAllTrafficRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/trafficRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

// NewUpdateTrafficRulesRequest calls the generic UpdateTrafficRules builder with application/json body
func NewUpdateTrafficRulesRequest(server string, params *UpdateTrafficRulesParams, body UpdateTrafficRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTrafficRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateTrafficRulesRequestWithBody generates requests for UpdateTrafficRules with any type of body
func NewUpdateTrafficRulesRequestWithBody(server string, params *UpdateTrafficRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/trafficRules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-api-version", runtime.ParamLocationHeader, params.XApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-api-version", headerParam0)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateAuthorizationCodeWithResponse request
	CreateAuthorizationCodeWithResponse(ctx context.Context, params *CreateAuthorizationCodeParams, reqEditors ...RequestEditorFn) (*CreateAuthorizationCodeResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithFormdataBodyWithResponse(ctx context.Context, params *CreateTokenParams, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// ExportCredentialsWithBodyWithResponse request with any body
	ExportCredentialsWithBodyWithResponse(ctx context.Context, params *ExportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportCredentialsResponse, error)

	ExportCredentialsWithResponse(ctx context.Context, params *ExportCredentialsParams, body ExportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportCredentialsResponse, error)

	// ImportCredentialsWithBodyWithResponse request with any body
	ImportCredentialsWithBodyWithResponse(ctx context.Context, params *ImportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportCredentialsResponse, error)

	ImportCredentialsWithResponse(ctx context.Context, params *ImportCredentialsParams, body ImportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportCredentialsResponse, error)

	// ExportEncryptionPasswordsWithBodyWithResponse request with any body
	ExportEncryptionPasswordsWithBodyWithResponse(ctx context.Context, params *ExportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEncryptionPasswordsResponse, error)

	ExportEncryptionPasswordsWithResponse(ctx context.Context, params *ExportEncryptionPasswordsParams, body ExportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEncryptionPasswordsResponse, error)

	// ImportEncryptionPasswordsWithBodyWithResponse request with any body
	ImportEncryptionPasswordsWithBodyWithResponse(ctx context.Context, params *ImportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEncryptionPasswordsResponse, error)

	ImportEncryptionPasswordsWithResponse(ctx context.Context, params *ImportEncryptionPasswordsParams, body ImportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEncryptionPasswordsResponse, error)

	// ExportJobsWithBodyWithResponse request with any body
	ExportJobsWithBodyWithResponse(ctx context.Context, params *ExportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportJobsResponse, error)

	ExportJobsWithResponse(ctx context.Context, params *ExportJobsParams, body ExportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportJobsResponse, error)

	// ImportJobsWithBodyWithResponse request with any body
	ImportJobsWithBodyWithResponse(ctx context.Context, params *ImportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportJobsResponse, error)

	ImportJobsWithResponse(ctx context.Context, params *ImportJobsParams, body ImportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportJobsResponse, error)

	// ExportManagedServersWithBodyWithResponse request with any body
	ExportManagedServersWithBodyWithResponse(ctx context.Context, params *ExportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportManagedServersResponse, error)

	ExportManagedServersWithResponse(ctx context.Context, params *ExportManagedServersParams, body ExportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportManagedServersResponse, error)

	// ImportManagedServersWithBodyWithResponse request with any body
	ImportManagedServersWithBodyWithResponse(ctx context.Context, params *ImportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportManagedServersResponse, error)

	ImportManagedServersWithResponse(ctx context.Context, params *ImportManagedServersParams, body ImportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportManagedServersResponse, error)

	// ExportProxiesWithBodyWithResponse request with any body
	ExportProxiesWithBodyWithResponse(ctx context.Context, params *ExportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportProxiesResponse, error)

	ExportProxiesWithResponse(ctx context.Context, params *ExportProxiesParams, body ExportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportProxiesResponse, error)

	// ImportProxiesWithBodyWithResponse request with any body
	ImportProxiesWithBodyWithResponse(ctx context.Context, params *ImportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportProxiesResponse, error)

	ImportProxiesWithResponse(ctx context.Context, params *ImportProxiesParams, body ImportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportProxiesResponse, error)

	// ExportRepositoriesWithBodyWithResponse request with any body
	ExportRepositoriesWithBodyWithResponse(ctx context.Context, params *ExportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportRepositoriesResponse, error)

	ExportRepositoriesWithResponse(ctx context.Context, params *ExportRepositoriesParams, body ExportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportRepositoriesResponse, error)

	// ImportRepositoriesWithBodyWithResponse request with any body
	ImportRepositoriesWithBodyWithResponse(ctx context.Context, params *ImportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportRepositoriesResponse, error)

	ImportRepositoriesWithResponse(ctx context.Context, params *ImportRepositoriesParams, body ImportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportRepositoriesResponse, error)

	// GetAllAutomationSessionsWithResponse request
	GetAllAutomationSessionsWithResponse(ctx context.Context, params *GetAllAutomationSessionsParams, reqEditors ...RequestEditorFn) (*GetAllAutomationSessionsResponse, error)

	// GetAutomationSessionWithResponse request
	GetAutomationSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionParams, reqEditors ...RequestEditorFn) (*GetAutomationSessionResponse, error)

	// GetAutomationSessionLogsWithResponse request
	GetAutomationSessionLogsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionLogsParams, reqEditors ...RequestEditorFn) (*GetAutomationSessionLogsResponse, error)

	// StopAutomationSessionWithResponse request
	StopAutomationSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *StopAutomationSessionParams, reqEditors ...RequestEditorFn) (*StopAutomationSessionResponse, error)

	// GetAllManagedServersWithResponse request
	GetAllManagedServersWithResponse(ctx context.Context, params *GetAllManagedServersParams, reqEditors ...RequestEditorFn) (*GetAllManagedServersResponse, error)

	// CreateManagedServerWithBodyWithResponse request with any body
	CreateManagedServerWithBodyWithResponse(ctx context.Context, params *CreateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagedServerResponse, error)

	CreateManagedServerWithResponse(ctx context.Context, params *CreateManagedServerParams, body CreateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagedServerResponse, error)

	// DeleteManagedServerWithResponse request
	DeleteManagedServerWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteManagedServerParams, reqEditors ...RequestEditorFn) (*DeleteManagedServerResponse, error)

	// GetManagedServerWithResponse request
	GetManagedServerWithResponse(ctx context.Context, id openapi_types.UUID, params *GetManagedServerParams, reqEditors ...RequestEditorFn) (*GetManagedServerResponse, error)

	// UpdateManagedServerWithBodyWithResponse request with any body
	UpdateManagedServerWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManagedServerResponse, error)

	UpdateManagedServerWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, body UpdateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManagedServerResponse, error)

	// GetAllProxiesWithResponse request
	GetAllProxiesWithResponse(ctx context.Context, params *GetAllProxiesParams, reqEditors ...RequestEditorFn) (*GetAllProxiesResponse, error)

	// CreateProxyWithBodyWithResponse request with any body
	CreateProxyWithBodyWithResponse(ctx context.Context, params *CreateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProxyResponse, error)

	CreateProxyWithResponse(ctx context.Context, params *CreateProxyParams, body CreateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProxyResponse, error)

	// DeleteProxyWithResponse request
	DeleteProxyWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteProxyParams, reqEditors ...RequestEditorFn) (*DeleteProxyResponse, error)

	// GetProxyWithResponse request
	GetProxyWithResponse(ctx context.Context, id openapi_types.UUID, params *GetProxyParams, reqEditors ...RequestEditorFn) (*GetProxyResponse, error)

	// UpdateProxyWithBodyWithResponse request with any body
	UpdateProxyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProxyResponse, error)

	UpdateProxyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, body UpdateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProxyResponse, error)

	// GetAllRepositoriesWithResponse request
	GetAllRepositoriesWithResponse(ctx context.Context, params *GetAllRepositoriesParams, reqEditors ...RequestEditorFn) (*GetAllRepositoriesResponse, error)

	// CreateRepositoryWithBodyWithResponse request with any body
	CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	// GetAllRepositoriesStatesWithResponse request
	GetAllRepositoriesStatesWithResponse(ctx context.Context, params *GetAllRepositoriesStatesParams, reqEditors ...RequestEditorFn) (*GetAllRepositoriesStatesResponse, error)

	// DeleteRepositoryWithResponse request
	DeleteRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error)

	// GetRepositoryWithResponse request
	GetRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *GetRepositoryParams, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error)

	// UpdateRepositoryWithBodyWithResponse request with any body
	UpdateRepositoryWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error)

	UpdateRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error)

	// GetAllScaleOutRepositoriesWithResponse request
	GetAllScaleOutRepositoriesWithResponse(ctx context.Context, params *GetAllScaleOutRepositoriesParams, reqEditors ...RequestEditorFn) (*GetAllScaleOutRepositoriesResponse, error)

	// GetScaleOutRepositoryWithResponse request
	GetScaleOutRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *GetScaleOutRepositoryParams, reqEditors ...RequestEditorFn) (*GetScaleOutRepositoryResponse, error)

	// DisableScaleOutExtentMaintenanceModeWithBodyWithResponse request with any body
	DisableScaleOutExtentMaintenanceModeWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableScaleOutExtentMaintenanceModeResponse, error)

	DisableScaleOutExtentMaintenanceModeWithResponse(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, body DisableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableScaleOutExtentMaintenanceModeResponse, error)

	// EnableScaleOutExtentMaintenanceModeWithBodyWithResponse request with any body
	EnableScaleOutExtentMaintenanceModeWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableScaleOutExtentMaintenanceModeResponse, error)

	EnableScaleOutExtentMaintenanceModeWithResponse(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, body EnableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableScaleOutExtentMaintenanceModeResponse, error)

	// GetAllBackupObjectsWithResponse request
	GetAllBackupObjectsWithResponse(ctx context.Context, params *GetAllBackupObjectsParams, reqEditors ...RequestEditorFn) (*GetAllBackupObjectsResponse, error)

	// GetBackupObjectWithResponse request
	GetBackupObjectWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectParams, reqEditors ...RequestEditorFn) (*GetBackupObjectResponse, error)

	// GetBackupObjectRestorePointsWithResponse request
	GetBackupObjectRestorePointsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*GetBackupObjectRestorePointsResponse, error)

	// GetAllBackupsWithResponse request
	GetAllBackupsWithResponse(ctx context.Context, params *GetAllBackupsParams, reqEditors ...RequestEditorFn) (*GetAllBackupsResponse, error)

	// GetBackupWithResponse request
	GetBackupWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupParams, reqEditors ...RequestEditorFn) (*GetBackupResponse, error)

	// GetBackupObjectsWithResponse request
	GetBackupObjectsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectsParams, reqEditors ...RequestEditorFn) (*GetBackupObjectsResponse, error)

	// GetConfigBackupOptionsWithResponse request
	GetConfigBackupOptionsWithResponse(ctx context.Context, params *GetConfigBackupOptionsParams, reqEditors ...RequestEditorFn) (*GetConfigBackupOptionsResponse, error)

	// UpdateConfigBackupOptionsWithBodyWithResponse request with any body
	UpdateConfigBackupOptionsWithBodyWithResponse(ctx context.Context, params *UpdateConfigBackupOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigBackupOptionsResponse, error)

	UpdateConfigBackupOptionsWithResponse(ctx context.Context, params *UpdateConfigBackupOptionsParams, body UpdateConfigBackupOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigBackupOptionsResponse, error)

	// StartConfigBackupWithResponse request
	StartConfigBackupWithResponse(ctx context.Context, params *StartConfigBackupParams, reqEditors ...RequestEditorFn) (*StartConfigBackupResponse, error)

	// GetConnectionCertificateWithBodyWithResponse request with any body
	GetConnectionCertificateWithBodyWithResponse(ctx context.Context, params *GetConnectionCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetConnectionCertificateResponse, error)

	GetConnectionCertificateWithResponse(ctx context.Context, params *GetConnectionCertificateParams, body GetConnectionCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*GetConnectionCertificateResponse, error)

	// GetAllCredsWithResponse request
	GetAllCredsWithResponse(ctx context.Context, params *GetAllCredsParams, reqEditors ...RequestEditorFn) (*GetAllCredsResponse, error)

	// CreateCredsWithBodyWithResponse request with any body
	CreateCredsWithBodyWithResponse(ctx context.Context, params *CreateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCredsResponse, error)

	CreateCredsWithResponse(ctx context.Context, params *CreateCredsParams, body CreateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCredsResponse, error)

	// DeleteCredsWithResponse request
	DeleteCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteCredsParams, reqEditors ...RequestEditorFn) (*DeleteCredsResponse, error)

	// GetCredsWithResponse request
	GetCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetCredsParams, reqEditors ...RequestEditorFn) (*GetCredsResponse, error)

	// UpdateCredsWithBodyWithResponse request with any body
	UpdateCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCredsResponse, error)

	UpdateCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, body UpdateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCredsResponse, error)

	// ChangePasswordForCredsWithBodyWithResponse request with any body
	ChangePasswordForCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordForCredsResponse, error)

	ChangePasswordForCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, body ChangePasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordForCredsResponse, error)

	// ChangePrivateKeyForCredsWithBodyWithResponse request with any body
	ChangePrivateKeyForCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePrivateKeyForCredsResponse, error)

	ChangePrivateKeyForCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, body ChangePrivateKeyForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePrivateKeyForCredsResponse, error)

	// ChangeRootPasswordForCredsWithBodyWithResponse request with any body
	ChangeRootPasswordForCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeRootPasswordForCredsResponse, error)

	ChangeRootPasswordForCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, body ChangeRootPasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeRootPasswordForCredsResponse, error)

	// GetAllEncryptionPasswordsWithResponse request
	GetAllEncryptionPasswordsWithResponse(ctx context.Context, params *GetAllEncryptionPasswordsParams, reqEditors ...RequestEditorFn) (*GetAllEncryptionPasswordsResponse, error)

	// CreateEncryptionPasswordWithBodyWithResponse request with any body
	CreateEncryptionPasswordWithBodyWithResponse(ctx context.Context, params *CreateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEncryptionPasswordResponse, error)

	CreateEncryptionPasswordWithResponse(ctx context.Context, params *CreateEncryptionPasswordParams, body CreateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEncryptionPasswordResponse, error)

	// DeleteEncryptionPasswordWithResponse request
	DeleteEncryptionPasswordWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*DeleteEncryptionPasswordResponse, error)

	// GetEncryptionPasswordWithResponse request
	GetEncryptionPasswordWithResponse(ctx context.Context, id openapi_types.UUID, params *GetEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*GetEncryptionPasswordResponse, error)

	// UpdateEncryptionPasswordWithBodyWithResponse request with any body
	UpdateEncryptionPasswordWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEncryptionPasswordResponse, error)

	UpdateEncryptionPasswordWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, body UpdateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEncryptionPasswordResponse, error)

	// GetGeneralOptionsWithResponse request
	GetGeneralOptionsWithResponse(ctx context.Context, params *GetGeneralOptionsParams, reqEditors ...RequestEditorFn) (*GetGeneralOptionsResponse, error)

	// UpdateGeneralOptionsWithBodyWithResponse request with any body
	UpdateGeneralOptionsWithBodyWithResponse(ctx context.Context, params *UpdateGeneralOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGeneralOptionsResponse, error)

	UpdateGeneralOptionsWithResponse(ctx context.Context, params *UpdateGeneralOptionsParams, body UpdateGeneralOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGeneralOptionsResponse, error)

	// GetAllInventoryVmwareHostsWithResponse request
	GetAllInventoryVmwareHostsWithResponse(ctx context.Context, params *GetAllInventoryVmwareHostsParams, reqEditors ...RequestEditorFn) (*GetAllInventoryVmwareHostsResponse, error)

	// GetVmwareHostObjectWithResponse request
	GetVmwareHostObjectWithResponse(ctx context.Context, name string, params *GetVmwareHostObjectParams, reqEditors ...RequestEditorFn) (*GetVmwareHostObjectResponse, error)

	// GetAllJobsWithResponse request
	GetAllJobsWithResponse(ctx context.Context, params *GetAllJobsParams, reqEditors ...RequestEditorFn) (*GetAllJobsResponse, error)

	// CreateJobWithBodyWithResponse request with any body
	CreateJobWithBodyWithResponse(ctx context.Context, params *CreateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	CreateJobWithResponse(ctx context.Context, params *CreateJobParams, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error)

	// GetAllJobsStatesWithResponse request
	GetAllJobsStatesWithResponse(ctx context.Context, params *GetAllJobsStatesParams, reqEditors ...RequestEditorFn) (*GetAllJobsStatesResponse, error)

	// DeleteJobWithResponse request
	DeleteJobWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, id openapi_types.UUID, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// UpdateJobWithBodyWithResponse request with any body
	UpdateJobWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	UpdateJobWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error)

	// DisableJobWithResponse request
	DisableJobWithResponse(ctx context.Context, id openapi_types.UUID, params *DisableJobParams, reqEditors ...RequestEditorFn) (*DisableJobResponse, error)

	// EnableJobWithResponse request
	EnableJobWithResponse(ctx context.Context, id openapi_types.UUID, params *EnableJobParams, reqEditors ...RequestEditorFn) (*EnableJobResponse, error)

	// StartJobWithBodyWithResponse request with any body
	StartJobWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *StartJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartJobResponse, error)

	StartJobWithResponse(ctx context.Context, id openapi_types.UUID, params *StartJobParams, body StartJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartJobResponse, error)

	// StopJobWithBodyWithResponse request with any body
	StopJobWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *StopJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopJobResponse, error)

	StopJobWithResponse(ctx context.Context, id openapi_types.UUID, params *StopJobParams, body StopJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StopJobResponse, error)

	// GetAllObjectRestorePointsWithResponse request
	GetAllObjectRestorePointsWithResponse(ctx context.Context, params *GetAllObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*GetAllObjectRestorePointsResponse, error)

	// GetObjectRestorePointWithResponse request
	GetObjectRestorePointWithResponse(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointParams, reqEditors ...RequestEditorFn) (*GetObjectRestorePointResponse, error)

	// GetObjectRestorePointDisksWithResponse request
	GetObjectRestorePointDisksWithResponse(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointDisksParams, reqEditors ...RequestEditorFn) (*GetObjectRestorePointDisksResponse, error)

	// InstantRecoveryVmwareFcdMountWithBodyWithResponse request with any body
	InstantRecoveryVmwareFcdMountWithBodyWithResponse(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMountResponse, error)

	InstantRecoveryVmwareFcdMountWithResponse(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, body InstantRecoveryVmwareFcdMountJSONRequestBody, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMountResponse, error)

	// GetVmwareFcdInstantRecoveryMountModelWithResponse request
	GetVmwareFcdInstantRecoveryMountModelWithResponse(ctx context.Context, mountId openapi_types.UUID, params *GetVmwareFcdInstantRecoveryMountModelParams, reqEditors ...RequestEditorFn) (*GetVmwareFcdInstantRecoveryMountModelResponse, error)

	// InstantRecoveryVmwareFcdDismountWithResponse request
	InstantRecoveryVmwareFcdDismountWithResponse(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdDismountParams, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdDismountResponse, error)

	// InstantRecoveryVmwareFcdMigrateWithBodyWithResponse request with any body
	InstantRecoveryVmwareFcdMigrateWithBodyWithResponse(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMigrateResponse, error)

	InstantRecoveryVmwareFcdMigrateWithResponse(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, body InstantRecoveryVmwareFcdMigrateJSONRequestBody, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMigrateResponse, error)

	// GetServerCertificateWithResponse request
	GetServerCertificateWithResponse(ctx context.Context, params *GetServerCertificateParams, reqEditors ...RequestEditorFn) (*GetServerCertificateResponse, error)

	// GetServerTimeWithResponse request
	GetServerTimeWithResponse(ctx context.Context, params *GetServerTimeParams, reqEditors ...RequestEditorFn) (*GetServerTimeResponse, error)

	// GetAllServicesWithResponse request
	GetAllServicesWithResponse(ctx context.Context, params *GetAllServicesParams, reqEditors ...RequestEditorFn) (*GetAllServicesResponse, error)

	// GetAllSessionsWithResponse request
	GetAllSessionsWithResponse(ctx context.Context, params *GetAllSessionsParams, reqEditors ...RequestEditorFn) (*GetAllSessionsResponse, error)

	// GetSessionWithResponse request
	GetSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSessionParams, reqEditors ...RequestEditorFn) (*GetSessionResponse, error)

	// GetSessionLogsWithResponse request
	GetSessionLogsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSessionLogsParams, reqEditors ...RequestEditorFn) (*GetSessionLogsResponse, error)

	// StopSessionWithResponse request
	StopSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *StopSessionParams, reqEditors ...RequestEditorFn) (*StopSessionResponse, error)

	// GetAllTrafficRulesWithResponse request
	GetAllTrafficRulesWithResponse(ctx context.Context, params *GetAllTrafficRulesParams, reqEditors ...RequestEditorFn) (*GetAllTrafficRulesResponse, error)

	// UpdateTrafficRulesWithBodyWithResponse request with any body
	UpdateTrafficRulesWithBodyWithResponse(ctx context.Context, params *UpdateTrafficRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTrafficRulesResponse, error)

	UpdateTrafficRulesWithResponse(ctx context.Context, params *UpdateTrafficRulesParams, body UpdateTrafficRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTrafficRulesResponse, error)
}

type CreateAuthorizationCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorizationCodeModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAuthorizationCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAuthorizationCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsImportSpecCollection
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportEncryptionPasswordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncryptionPasswordImportSpecCollection
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportEncryptionPasswordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportEncryptionPasswordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportEncryptionPasswordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportEncryptionPasswordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportEncryptionPasswordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobImportSpecCollection
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportManagedServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManageServerImportSpecCollection
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportManagedServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportManagedServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportManagedServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportManagedServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportManagedServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportProxiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyImportSpecCollection
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportProxiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportProxiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportProxiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportProxiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportProxiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryImportSpecCollection
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAutomationSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllAutomationSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAutomationSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomationSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAutomationSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomationSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomationSessionLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLogResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAutomationSessionLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomationSessionLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopAutomationSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StopAutomationSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopAutomationSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllManagedServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedServersResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllManagedServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllManagedServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManagedServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateManagedServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManagedServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManagedServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteManagedServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManagedServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManagedServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ManagedServerModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetManagedServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManagedServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateManagedServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateManagedServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateManagedServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllProxiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxiesResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllProxiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllProxiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Deleted
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProxyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProxyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProxyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoriesResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRepositoriesStatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryStatesResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllRepositoriesStatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRepositoriesStatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptySuccessResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllScaleOutRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScaleOutRepositoriesResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllScaleOutRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllScaleOutRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScaleOutRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScaleOutRepositoryModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetScaleOutRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScaleOutRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableScaleOutExtentMaintenanceModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DisableScaleOutExtentMaintenanceModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableScaleOutExtentMaintenanceModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableScaleOutExtentMaintenanceModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EnableScaleOutExtentMaintenanceModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableScaleOutExtentMaintenanceModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBackupObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupObjectsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllBackupObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBackupObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupObjectModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackupObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupObjectRestorePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectRestorePointsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackupObjectRestorePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupObjectRestorePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupObjectsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackupObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigBackupOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigBackupModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetConfigBackupOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigBackupOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigBackupOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigBackupModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateConfigBackupOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigBackupOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartConfigBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartConfigBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartConfigBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectionCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConnectionCertificateModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetConnectionCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectionCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CredentialsModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptySuccessResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePasswordForCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ChangePasswordForCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePasswordForCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePrivateKeyForCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ChangePrivateKeyForCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePrivateKeyForCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeRootPasswordForCredsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ChangeRootPasswordForCredsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeRootPasswordForCredsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllEncryptionPasswordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncryptionPasswordsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllEncryptionPasswordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllEncryptionPasswordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEncryptionPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EncryptionPasswordModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateEncryptionPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEncryptionPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEncryptionPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *EmptySuccessResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteEncryptionPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEncryptionPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEncryptionPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncryptionPasswordModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEncryptionPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEncryptionPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEncryptionPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncryptionPasswordModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateEncryptionPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEncryptionPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGeneralOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeneralOptionsModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGeneralOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGeneralOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGeneralOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeneralOptionsModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateGeneralOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGeneralOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllInventoryVmwareHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ViRootsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllInventoryVmwareHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllInventoryVmwareHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmwareHostObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VCenterInventoryResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetVmwareHostObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmwareHostObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *JobModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllJobsStatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobStatesResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllJobsStatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllJobsStatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *Deleted
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DisableJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EnableJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StartJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SessionModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StopJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllObjectRestorePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectRestorePointsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllObjectRestorePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllObjectRestorePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectRestorePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectRestorePointModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetObjectRestorePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectRestorePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectRestorePointDisksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectRestorePointDisksResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetObjectRestorePointDisksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectRestorePointDisksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstantRecoveryVmwareFcdMountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VmwareFcdInstantRecoveryMount
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r InstantRecoveryVmwareFcdMountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstantRecoveryVmwareFcdMountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVmwareFcdInstantRecoveryMountModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VmwareFcdInstantRecoveryMount
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetVmwareFcdInstantRecoveryMountModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVmwareFcdInstantRecoveryMountModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstantRecoveryVmwareFcdDismountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VmwareFcdInstantRecoveryMount
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r InstantRecoveryVmwareFcdDismountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstantRecoveryVmwareFcdDismountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstantRecoveryVmwareFcdMigrateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VmwareFcdInstantRecoveryMount
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r InstantRecoveryVmwareFcdMigrateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstantRecoveryVmwareFcdMigrateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetServerCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTimeModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetServerTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServicesResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionsResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionLogResult
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSessionLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptySuccessResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r StopSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTrafficRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalNetworkTrafficRulesModel
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllTrafficRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTrafficRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTrafficRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GlobalNetworkTrafficRulesModel
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateTrafficRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTrafficRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateAuthorizationCodeWithResponse request returning *CreateAuthorizationCodeResponse
func (c *ClientWithResponses) CreateAuthorizationCodeWithResponse(ctx context.Context, params *CreateAuthorizationCodeParams, reqEditors ...RequestEditorFn) (*CreateAuthorizationCodeResponse, error) {
	rsp, err := c.CreateAuthorizationCode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAuthorizationCodeResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, params *CreateTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithFormdataBodyWithResponse(ctx context.Context, params *CreateTokenParams, body CreateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// ExportCredentialsWithBodyWithResponse request with arbitrary body returning *ExportCredentialsResponse
func (c *ClientWithResponses) ExportCredentialsWithBodyWithResponse(ctx context.Context, params *ExportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportCredentialsResponse, error) {
	rsp, err := c.ExportCredentialsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportCredentialsResponse(rsp)
}

func (c *ClientWithResponses) ExportCredentialsWithResponse(ctx context.Context, params *ExportCredentialsParams, body ExportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportCredentialsResponse, error) {
	rsp, err := c.ExportCredentials(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportCredentialsResponse(rsp)
}

// ImportCredentialsWithBodyWithResponse request with arbitrary body returning *ImportCredentialsResponse
func (c *ClientWithResponses) ImportCredentialsWithBodyWithResponse(ctx context.Context, params *ImportCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportCredentialsResponse, error) {
	rsp, err := c.ImportCredentialsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCredentialsResponse(rsp)
}

func (c *ClientWithResponses) ImportCredentialsWithResponse(ctx context.Context, params *ImportCredentialsParams, body ImportCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportCredentialsResponse, error) {
	rsp, err := c.ImportCredentials(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCredentialsResponse(rsp)
}

// ExportEncryptionPasswordsWithBodyWithResponse request with arbitrary body returning *ExportEncryptionPasswordsResponse
func (c *ClientWithResponses) ExportEncryptionPasswordsWithBodyWithResponse(ctx context.Context, params *ExportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportEncryptionPasswordsResponse, error) {
	rsp, err := c.ExportEncryptionPasswordsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEncryptionPasswordsResponse(rsp)
}

func (c *ClientWithResponses) ExportEncryptionPasswordsWithResponse(ctx context.Context, params *ExportEncryptionPasswordsParams, body ExportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportEncryptionPasswordsResponse, error) {
	rsp, err := c.ExportEncryptionPasswords(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportEncryptionPasswordsResponse(rsp)
}

// ImportEncryptionPasswordsWithBodyWithResponse request with arbitrary body returning *ImportEncryptionPasswordsResponse
func (c *ClientWithResponses) ImportEncryptionPasswordsWithBodyWithResponse(ctx context.Context, params *ImportEncryptionPasswordsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportEncryptionPasswordsResponse, error) {
	rsp, err := c.ImportEncryptionPasswordsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEncryptionPasswordsResponse(rsp)
}

func (c *ClientWithResponses) ImportEncryptionPasswordsWithResponse(ctx context.Context, params *ImportEncryptionPasswordsParams, body ImportEncryptionPasswordsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportEncryptionPasswordsResponse, error) {
	rsp, err := c.ImportEncryptionPasswords(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportEncryptionPasswordsResponse(rsp)
}

// ExportJobsWithBodyWithResponse request with arbitrary body returning *ExportJobsResponse
func (c *ClientWithResponses) ExportJobsWithBodyWithResponse(ctx context.Context, params *ExportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportJobsResponse, error) {
	rsp, err := c.ExportJobsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportJobsResponse(rsp)
}

func (c *ClientWithResponses) ExportJobsWithResponse(ctx context.Context, params *ExportJobsParams, body ExportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportJobsResponse, error) {
	rsp, err := c.ExportJobs(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportJobsResponse(rsp)
}

// ImportJobsWithBodyWithResponse request with arbitrary body returning *ImportJobsResponse
func (c *ClientWithResponses) ImportJobsWithBodyWithResponse(ctx context.Context, params *ImportJobsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportJobsResponse, error) {
	rsp, err := c.ImportJobsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportJobsResponse(rsp)
}

func (c *ClientWithResponses) ImportJobsWithResponse(ctx context.Context, params *ImportJobsParams, body ImportJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportJobsResponse, error) {
	rsp, err := c.ImportJobs(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportJobsResponse(rsp)
}

// ExportManagedServersWithBodyWithResponse request with arbitrary body returning *ExportManagedServersResponse
func (c *ClientWithResponses) ExportManagedServersWithBodyWithResponse(ctx context.Context, params *ExportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportManagedServersResponse, error) {
	rsp, err := c.ExportManagedServersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportManagedServersResponse(rsp)
}

func (c *ClientWithResponses) ExportManagedServersWithResponse(ctx context.Context, params *ExportManagedServersParams, body ExportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportManagedServersResponse, error) {
	rsp, err := c.ExportManagedServers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportManagedServersResponse(rsp)
}

// ImportManagedServersWithBodyWithResponse request with arbitrary body returning *ImportManagedServersResponse
func (c *ClientWithResponses) ImportManagedServersWithBodyWithResponse(ctx context.Context, params *ImportManagedServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportManagedServersResponse, error) {
	rsp, err := c.ImportManagedServersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportManagedServersResponse(rsp)
}

func (c *ClientWithResponses) ImportManagedServersWithResponse(ctx context.Context, params *ImportManagedServersParams, body ImportManagedServersJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportManagedServersResponse, error) {
	rsp, err := c.ImportManagedServers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportManagedServersResponse(rsp)
}

// ExportProxiesWithBodyWithResponse request with arbitrary body returning *ExportProxiesResponse
func (c *ClientWithResponses) ExportProxiesWithBodyWithResponse(ctx context.Context, params *ExportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportProxiesResponse, error) {
	rsp, err := c.ExportProxiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportProxiesResponse(rsp)
}

func (c *ClientWithResponses) ExportProxiesWithResponse(ctx context.Context, params *ExportProxiesParams, body ExportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportProxiesResponse, error) {
	rsp, err := c.ExportProxies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportProxiesResponse(rsp)
}

// ImportProxiesWithBodyWithResponse request with arbitrary body returning *ImportProxiesResponse
func (c *ClientWithResponses) ImportProxiesWithBodyWithResponse(ctx context.Context, params *ImportProxiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportProxiesResponse, error) {
	rsp, err := c.ImportProxiesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportProxiesResponse(rsp)
}

func (c *ClientWithResponses) ImportProxiesWithResponse(ctx context.Context, params *ImportProxiesParams, body ImportProxiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportProxiesResponse, error) {
	rsp, err := c.ImportProxies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportProxiesResponse(rsp)
}

// ExportRepositoriesWithBodyWithResponse request with arbitrary body returning *ExportRepositoriesResponse
func (c *ClientWithResponses) ExportRepositoriesWithBodyWithResponse(ctx context.Context, params *ExportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportRepositoriesResponse, error) {
	rsp, err := c.ExportRepositoriesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportRepositoriesResponse(rsp)
}

func (c *ClientWithResponses) ExportRepositoriesWithResponse(ctx context.Context, params *ExportRepositoriesParams, body ExportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportRepositoriesResponse, error) {
	rsp, err := c.ExportRepositories(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportRepositoriesResponse(rsp)
}

// ImportRepositoriesWithBodyWithResponse request with arbitrary body returning *ImportRepositoriesResponse
func (c *ClientWithResponses) ImportRepositoriesWithBodyWithResponse(ctx context.Context, params *ImportRepositoriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportRepositoriesResponse, error) {
	rsp, err := c.ImportRepositoriesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportRepositoriesResponse(rsp)
}

func (c *ClientWithResponses) ImportRepositoriesWithResponse(ctx context.Context, params *ImportRepositoriesParams, body ImportRepositoriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportRepositoriesResponse, error) {
	rsp, err := c.ImportRepositories(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportRepositoriesResponse(rsp)
}

// GetAllAutomationSessionsWithResponse request returning *GetAllAutomationSessionsResponse
func (c *ClientWithResponses) GetAllAutomationSessionsWithResponse(ctx context.Context, params *GetAllAutomationSessionsParams, reqEditors ...RequestEditorFn) (*GetAllAutomationSessionsResponse, error) {
	rsp, err := c.GetAllAutomationSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAutomationSessionsResponse(rsp)
}

// GetAutomationSessionWithResponse request returning *GetAutomationSessionResponse
func (c *ClientWithResponses) GetAutomationSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionParams, reqEditors ...RequestEditorFn) (*GetAutomationSessionResponse, error) {
	rsp, err := c.GetAutomationSession(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutomationSessionResponse(rsp)
}

// GetAutomationSessionLogsWithResponse request returning *GetAutomationSessionLogsResponse
func (c *ClientWithResponses) GetAutomationSessionLogsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAutomationSessionLogsParams, reqEditors ...RequestEditorFn) (*GetAutomationSessionLogsResponse, error) {
	rsp, err := c.GetAutomationSessionLogs(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutomationSessionLogsResponse(rsp)
}

// StopAutomationSessionWithResponse request returning *StopAutomationSessionResponse
func (c *ClientWithResponses) StopAutomationSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *StopAutomationSessionParams, reqEditors ...RequestEditorFn) (*StopAutomationSessionResponse, error) {
	rsp, err := c.StopAutomationSession(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopAutomationSessionResponse(rsp)
}

// GetAllManagedServersWithResponse request returning *GetAllManagedServersResponse
func (c *ClientWithResponses) GetAllManagedServersWithResponse(ctx context.Context, params *GetAllManagedServersParams, reqEditors ...RequestEditorFn) (*GetAllManagedServersResponse, error) {
	rsp, err := c.GetAllManagedServers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllManagedServersResponse(rsp)
}

// CreateManagedServerWithBodyWithResponse request with arbitrary body returning *CreateManagedServerResponse
func (c *ClientWithResponses) CreateManagedServerWithBodyWithResponse(ctx context.Context, params *CreateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagedServerResponse, error) {
	rsp, err := c.CreateManagedServerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagedServerResponse(rsp)
}

func (c *ClientWithResponses) CreateManagedServerWithResponse(ctx context.Context, params *CreateManagedServerParams, body CreateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagedServerResponse, error) {
	rsp, err := c.CreateManagedServer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagedServerResponse(rsp)
}

// DeleteManagedServerWithResponse request returning *DeleteManagedServerResponse
func (c *ClientWithResponses) DeleteManagedServerWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteManagedServerParams, reqEditors ...RequestEditorFn) (*DeleteManagedServerResponse, error) {
	rsp, err := c.DeleteManagedServer(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManagedServerResponse(rsp)
}

// GetManagedServerWithResponse request returning *GetManagedServerResponse
func (c *ClientWithResponses) GetManagedServerWithResponse(ctx context.Context, id openapi_types.UUID, params *GetManagedServerParams, reqEditors ...RequestEditorFn) (*GetManagedServerResponse, error) {
	rsp, err := c.GetManagedServer(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManagedServerResponse(rsp)
}

// UpdateManagedServerWithBodyWithResponse request with arbitrary body returning *UpdateManagedServerResponse
func (c *ClientWithResponses) UpdateManagedServerWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateManagedServerResponse, error) {
	rsp, err := c.UpdateManagedServerWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManagedServerResponse(rsp)
}

func (c *ClientWithResponses) UpdateManagedServerWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateManagedServerParams, body UpdateManagedServerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateManagedServerResponse, error) {
	rsp, err := c.UpdateManagedServer(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateManagedServerResponse(rsp)
}

// GetAllProxiesWithResponse request returning *GetAllProxiesResponse
func (c *ClientWithResponses) GetAllProxiesWithResponse(ctx context.Context, params *GetAllProxiesParams, reqEditors ...RequestEditorFn) (*GetAllProxiesResponse, error) {
	rsp, err := c.GetAllProxies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllProxiesResponse(rsp)
}

// CreateProxyWithBodyWithResponse request with arbitrary body returning *CreateProxyResponse
func (c *ClientWithResponses) CreateProxyWithBodyWithResponse(ctx context.Context, params *CreateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProxyResponse, error) {
	rsp, err := c.CreateProxyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProxyResponse(rsp)
}

func (c *ClientWithResponses) CreateProxyWithResponse(ctx context.Context, params *CreateProxyParams, body CreateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProxyResponse, error) {
	rsp, err := c.CreateProxy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProxyResponse(rsp)
}

// DeleteProxyWithResponse request returning *DeleteProxyResponse
func (c *ClientWithResponses) DeleteProxyWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteProxyParams, reqEditors ...RequestEditorFn) (*DeleteProxyResponse, error) {
	rsp, err := c.DeleteProxy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProxyResponse(rsp)
}

// GetProxyWithResponse request returning *GetProxyResponse
func (c *ClientWithResponses) GetProxyWithResponse(ctx context.Context, id openapi_types.UUID, params *GetProxyParams, reqEditors ...RequestEditorFn) (*GetProxyResponse, error) {
	rsp, err := c.GetProxy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProxyResponse(rsp)
}

// UpdateProxyWithBodyWithResponse request with arbitrary body returning *UpdateProxyResponse
func (c *ClientWithResponses) UpdateProxyWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProxyResponse, error) {
	rsp, err := c.UpdateProxyWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProxyResponse(rsp)
}

func (c *ClientWithResponses) UpdateProxyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateProxyParams, body UpdateProxyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProxyResponse, error) {
	rsp, err := c.UpdateProxy(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProxyResponse(rsp)
}

// GetAllRepositoriesWithResponse request returning *GetAllRepositoriesResponse
func (c *ClientWithResponses) GetAllRepositoriesWithResponse(ctx context.Context, params *GetAllRepositoriesParams, reqEditors ...RequestEditorFn) (*GetAllRepositoriesResponse, error) {
	rsp, err := c.GetAllRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRepositoriesResponse(rsp)
}

// CreateRepositoryWithBodyWithResponse request with arbitrary body returning *CreateRepositoryResponse
func (c *ClientWithResponses) CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepositoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepository(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

// GetAllRepositoriesStatesWithResponse request returning *GetAllRepositoriesStatesResponse
func (c *ClientWithResponses) GetAllRepositoriesStatesWithResponse(ctx context.Context, params *GetAllRepositoriesStatesParams, reqEditors ...RequestEditorFn) (*GetAllRepositoriesStatesResponse, error) {
	rsp, err := c.GetAllRepositoriesStates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRepositoriesStatesResponse(rsp)
}

// DeleteRepositoryWithResponse request returning *DeleteRepositoryResponse
func (c *ClientWithResponses) DeleteRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error) {
	rsp, err := c.DeleteRepository(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryResponse(rsp)
}

// GetRepositoryWithResponse request returning *GetRepositoryResponse
func (c *ClientWithResponses) GetRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *GetRepositoryParams, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error) {
	rsp, err := c.GetRepository(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryResponse(rsp)
}

// UpdateRepositoryWithBodyWithResponse request with arbitrary body returning *UpdateRepositoryResponse
func (c *ClientWithResponses) UpdateRepositoryWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error) {
	rsp, err := c.UpdateRepositoryWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateRepositoryParams, body UpdateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRepositoryResponse, error) {
	rsp, err := c.UpdateRepository(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRepositoryResponse(rsp)
}

// GetAllScaleOutRepositoriesWithResponse request returning *GetAllScaleOutRepositoriesResponse
func (c *ClientWithResponses) GetAllScaleOutRepositoriesWithResponse(ctx context.Context, params *GetAllScaleOutRepositoriesParams, reqEditors ...RequestEditorFn) (*GetAllScaleOutRepositoriesResponse, error) {
	rsp, err := c.GetAllScaleOutRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllScaleOutRepositoriesResponse(rsp)
}

// GetScaleOutRepositoryWithResponse request returning *GetScaleOutRepositoryResponse
func (c *ClientWithResponses) GetScaleOutRepositoryWithResponse(ctx context.Context, id openapi_types.UUID, params *GetScaleOutRepositoryParams, reqEditors ...RequestEditorFn) (*GetScaleOutRepositoryResponse, error) {
	rsp, err := c.GetScaleOutRepository(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScaleOutRepositoryResponse(rsp)
}

// DisableScaleOutExtentMaintenanceModeWithBodyWithResponse request with arbitrary body returning *DisableScaleOutExtentMaintenanceModeResponse
func (c *ClientWithResponses) DisableScaleOutExtentMaintenanceModeWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableScaleOutExtentMaintenanceModeResponse, error) {
	rsp, err := c.DisableScaleOutExtentMaintenanceModeWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableScaleOutExtentMaintenanceModeResponse(rsp)
}

func (c *ClientWithResponses) DisableScaleOutExtentMaintenanceModeWithResponse(ctx context.Context, id openapi_types.UUID, params *DisableScaleOutExtentMaintenanceModeParams, body DisableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableScaleOutExtentMaintenanceModeResponse, error) {
	rsp, err := c.DisableScaleOutExtentMaintenanceMode(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableScaleOutExtentMaintenanceModeResponse(rsp)
}

// EnableScaleOutExtentMaintenanceModeWithBodyWithResponse request with arbitrary body returning *EnableScaleOutExtentMaintenanceModeResponse
func (c *ClientWithResponses) EnableScaleOutExtentMaintenanceModeWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableScaleOutExtentMaintenanceModeResponse, error) {
	rsp, err := c.EnableScaleOutExtentMaintenanceModeWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableScaleOutExtentMaintenanceModeResponse(rsp)
}

func (c *ClientWithResponses) EnableScaleOutExtentMaintenanceModeWithResponse(ctx context.Context, id openapi_types.UUID, params *EnableScaleOutExtentMaintenanceModeParams, body EnableScaleOutExtentMaintenanceModeJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableScaleOutExtentMaintenanceModeResponse, error) {
	rsp, err := c.EnableScaleOutExtentMaintenanceMode(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableScaleOutExtentMaintenanceModeResponse(rsp)
}

// GetAllBackupObjectsWithResponse request returning *GetAllBackupObjectsResponse
func (c *ClientWithResponses) GetAllBackupObjectsWithResponse(ctx context.Context, params *GetAllBackupObjectsParams, reqEditors ...RequestEditorFn) (*GetAllBackupObjectsResponse, error) {
	rsp, err := c.GetAllBackupObjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBackupObjectsResponse(rsp)
}

// GetBackupObjectWithResponse request returning *GetBackupObjectResponse
func (c *ClientWithResponses) GetBackupObjectWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectParams, reqEditors ...RequestEditorFn) (*GetBackupObjectResponse, error) {
	rsp, err := c.GetBackupObject(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupObjectResponse(rsp)
}

// GetBackupObjectRestorePointsWithResponse request returning *GetBackupObjectRestorePointsResponse
func (c *ClientWithResponses) GetBackupObjectRestorePointsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*GetBackupObjectRestorePointsResponse, error) {
	rsp, err := c.GetBackupObjectRestorePoints(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupObjectRestorePointsResponse(rsp)
}

// GetAllBackupsWithResponse request returning *GetAllBackupsResponse
func (c *ClientWithResponses) GetAllBackupsWithResponse(ctx context.Context, params *GetAllBackupsParams, reqEditors ...RequestEditorFn) (*GetAllBackupsResponse, error) {
	rsp, err := c.GetAllBackups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBackupsResponse(rsp)
}

// GetBackupWithResponse request returning *GetBackupResponse
func (c *ClientWithResponses) GetBackupWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupParams, reqEditors ...RequestEditorFn) (*GetBackupResponse, error) {
	rsp, err := c.GetBackup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupResponse(rsp)
}

// GetBackupObjectsWithResponse request returning *GetBackupObjectsResponse
func (c *ClientWithResponses) GetBackupObjectsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetBackupObjectsParams, reqEditors ...RequestEditorFn) (*GetBackupObjectsResponse, error) {
	rsp, err := c.GetBackupObjects(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupObjectsResponse(rsp)
}

// GetConfigBackupOptionsWithResponse request returning *GetConfigBackupOptionsResponse
func (c *ClientWithResponses) GetConfigBackupOptionsWithResponse(ctx context.Context, params *GetConfigBackupOptionsParams, reqEditors ...RequestEditorFn) (*GetConfigBackupOptionsResponse, error) {
	rsp, err := c.GetConfigBackupOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigBackupOptionsResponse(rsp)
}

// UpdateConfigBackupOptionsWithBodyWithResponse request with arbitrary body returning *UpdateConfigBackupOptionsResponse
func (c *ClientWithResponses) UpdateConfigBackupOptionsWithBodyWithResponse(ctx context.Context, params *UpdateConfigBackupOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigBackupOptionsResponse, error) {
	rsp, err := c.UpdateConfigBackupOptionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigBackupOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigBackupOptionsWithResponse(ctx context.Context, params *UpdateConfigBackupOptionsParams, body UpdateConfigBackupOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigBackupOptionsResponse, error) {
	rsp, err := c.UpdateConfigBackupOptions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigBackupOptionsResponse(rsp)
}

// StartConfigBackupWithResponse request returning *StartConfigBackupResponse
func (c *ClientWithResponses) StartConfigBackupWithResponse(ctx context.Context, params *StartConfigBackupParams, reqEditors ...RequestEditorFn) (*StartConfigBackupResponse, error) {
	rsp, err := c.StartConfigBackup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartConfigBackupResponse(rsp)
}

// GetConnectionCertificateWithBodyWithResponse request with arbitrary body returning *GetConnectionCertificateResponse
func (c *ClientWithResponses) GetConnectionCertificateWithBodyWithResponse(ctx context.Context, params *GetConnectionCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetConnectionCertificateResponse, error) {
	rsp, err := c.GetConnectionCertificateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionCertificateResponse(rsp)
}

func (c *ClientWithResponses) GetConnectionCertificateWithResponse(ctx context.Context, params *GetConnectionCertificateParams, body GetConnectionCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*GetConnectionCertificateResponse, error) {
	rsp, err := c.GetConnectionCertificate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectionCertificateResponse(rsp)
}

// GetAllCredsWithResponse request returning *GetAllCredsResponse
func (c *ClientWithResponses) GetAllCredsWithResponse(ctx context.Context, params *GetAllCredsParams, reqEditors ...RequestEditorFn) (*GetAllCredsResponse, error) {
	rsp, err := c.GetAllCreds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCredsResponse(rsp)
}

// CreateCredsWithBodyWithResponse request with arbitrary body returning *CreateCredsResponse
func (c *ClientWithResponses) CreateCredsWithBodyWithResponse(ctx context.Context, params *CreateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCredsResponse, error) {
	rsp, err := c.CreateCredsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredsResponse(rsp)
}

func (c *ClientWithResponses) CreateCredsWithResponse(ctx context.Context, params *CreateCredsParams, body CreateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCredsResponse, error) {
	rsp, err := c.CreateCreds(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredsResponse(rsp)
}

// DeleteCredsWithResponse request returning *DeleteCredsResponse
func (c *ClientWithResponses) DeleteCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteCredsParams, reqEditors ...RequestEditorFn) (*DeleteCredsResponse, error) {
	rsp, err := c.DeleteCreds(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredsResponse(rsp)
}

// GetCredsWithResponse request returning *GetCredsResponse
func (c *ClientWithResponses) GetCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetCredsParams, reqEditors ...RequestEditorFn) (*GetCredsResponse, error) {
	rsp, err := c.GetCreds(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredsResponse(rsp)
}

// UpdateCredsWithBodyWithResponse request with arbitrary body returning *UpdateCredsResponse
func (c *ClientWithResponses) UpdateCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCredsResponse, error) {
	rsp, err := c.UpdateCredsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCredsResponse(rsp)
}

func (c *ClientWithResponses) UpdateCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateCredsParams, body UpdateCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCredsResponse, error) {
	rsp, err := c.UpdateCreds(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCredsResponse(rsp)
}

// ChangePasswordForCredsWithBodyWithResponse request with arbitrary body returning *ChangePasswordForCredsResponse
func (c *ClientWithResponses) ChangePasswordForCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordForCredsResponse, error) {
	rsp, err := c.ChangePasswordForCredsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordForCredsResponse(rsp)
}

func (c *ClientWithResponses) ChangePasswordForCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePasswordForCredsParams, body ChangePasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordForCredsResponse, error) {
	rsp, err := c.ChangePasswordForCreds(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordForCredsResponse(rsp)
}

// ChangePrivateKeyForCredsWithBodyWithResponse request with arbitrary body returning *ChangePrivateKeyForCredsResponse
func (c *ClientWithResponses) ChangePrivateKeyForCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePrivateKeyForCredsResponse, error) {
	rsp, err := c.ChangePrivateKeyForCredsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePrivateKeyForCredsResponse(rsp)
}

func (c *ClientWithResponses) ChangePrivateKeyForCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangePrivateKeyForCredsParams, body ChangePrivateKeyForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePrivateKeyForCredsResponse, error) {
	rsp, err := c.ChangePrivateKeyForCreds(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePrivateKeyForCredsResponse(rsp)
}

// ChangeRootPasswordForCredsWithBodyWithResponse request with arbitrary body returning *ChangeRootPasswordForCredsResponse
func (c *ClientWithResponses) ChangeRootPasswordForCredsWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeRootPasswordForCredsResponse, error) {
	rsp, err := c.ChangeRootPasswordForCredsWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeRootPasswordForCredsResponse(rsp)
}

func (c *ClientWithResponses) ChangeRootPasswordForCredsWithResponse(ctx context.Context, id openapi_types.UUID, params *ChangeRootPasswordForCredsParams, body ChangeRootPasswordForCredsJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeRootPasswordForCredsResponse, error) {
	rsp, err := c.ChangeRootPasswordForCreds(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeRootPasswordForCredsResponse(rsp)
}

// GetAllEncryptionPasswordsWithResponse request returning *GetAllEncryptionPasswordsResponse
func (c *ClientWithResponses) GetAllEncryptionPasswordsWithResponse(ctx context.Context, params *GetAllEncryptionPasswordsParams, reqEditors ...RequestEditorFn) (*GetAllEncryptionPasswordsResponse, error) {
	rsp, err := c.GetAllEncryptionPasswords(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllEncryptionPasswordsResponse(rsp)
}

// CreateEncryptionPasswordWithBodyWithResponse request with arbitrary body returning *CreateEncryptionPasswordResponse
func (c *ClientWithResponses) CreateEncryptionPasswordWithBodyWithResponse(ctx context.Context, params *CreateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEncryptionPasswordResponse, error) {
	rsp, err := c.CreateEncryptionPasswordWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEncryptionPasswordResponse(rsp)
}

func (c *ClientWithResponses) CreateEncryptionPasswordWithResponse(ctx context.Context, params *CreateEncryptionPasswordParams, body CreateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEncryptionPasswordResponse, error) {
	rsp, err := c.CreateEncryptionPassword(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEncryptionPasswordResponse(rsp)
}

// DeleteEncryptionPasswordWithResponse request returning *DeleteEncryptionPasswordResponse
func (c *ClientWithResponses) DeleteEncryptionPasswordWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*DeleteEncryptionPasswordResponse, error) {
	rsp, err := c.DeleteEncryptionPassword(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEncryptionPasswordResponse(rsp)
}

// GetEncryptionPasswordWithResponse request returning *GetEncryptionPasswordResponse
func (c *ClientWithResponses) GetEncryptionPasswordWithResponse(ctx context.Context, id openapi_types.UUID, params *GetEncryptionPasswordParams, reqEditors ...RequestEditorFn) (*GetEncryptionPasswordResponse, error) {
	rsp, err := c.GetEncryptionPassword(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEncryptionPasswordResponse(rsp)
}

// UpdateEncryptionPasswordWithBodyWithResponse request with arbitrary body returning *UpdateEncryptionPasswordResponse
func (c *ClientWithResponses) UpdateEncryptionPasswordWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEncryptionPasswordResponse, error) {
	rsp, err := c.UpdateEncryptionPasswordWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEncryptionPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateEncryptionPasswordWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateEncryptionPasswordParams, body UpdateEncryptionPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEncryptionPasswordResponse, error) {
	rsp, err := c.UpdateEncryptionPassword(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEncryptionPasswordResponse(rsp)
}

// GetGeneralOptionsWithResponse request returning *GetGeneralOptionsResponse
func (c *ClientWithResponses) GetGeneralOptionsWithResponse(ctx context.Context, params *GetGeneralOptionsParams, reqEditors ...RequestEditorFn) (*GetGeneralOptionsResponse, error) {
	rsp, err := c.GetGeneralOptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGeneralOptionsResponse(rsp)
}

// UpdateGeneralOptionsWithBodyWithResponse request with arbitrary body returning *UpdateGeneralOptionsResponse
func (c *ClientWithResponses) UpdateGeneralOptionsWithBodyWithResponse(ctx context.Context, params *UpdateGeneralOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGeneralOptionsResponse, error) {
	rsp, err := c.UpdateGeneralOptionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGeneralOptionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateGeneralOptionsWithResponse(ctx context.Context, params *UpdateGeneralOptionsParams, body UpdateGeneralOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGeneralOptionsResponse, error) {
	rsp, err := c.UpdateGeneralOptions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGeneralOptionsResponse(rsp)
}

// GetAllInventoryVmwareHostsWithResponse request returning *GetAllInventoryVmwareHostsResponse
func (c *ClientWithResponses) GetAllInventoryVmwareHostsWithResponse(ctx context.Context, params *GetAllInventoryVmwareHostsParams, reqEditors ...RequestEditorFn) (*GetAllInventoryVmwareHostsResponse, error) {
	rsp, err := c.GetAllInventoryVmwareHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllInventoryVmwareHostsResponse(rsp)
}

// GetVmwareHostObjectWithResponse request returning *GetVmwareHostObjectResponse
func (c *ClientWithResponses) GetVmwareHostObjectWithResponse(ctx context.Context, name string, params *GetVmwareHostObjectParams, reqEditors ...RequestEditorFn) (*GetVmwareHostObjectResponse, error) {
	rsp, err := c.GetVmwareHostObject(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmwareHostObjectResponse(rsp)
}

// GetAllJobsWithResponse request returning *GetAllJobsResponse
func (c *ClientWithResponses) GetAllJobsWithResponse(ctx context.Context, params *GetAllJobsParams, reqEditors ...RequestEditorFn) (*GetAllJobsResponse, error) {
	rsp, err := c.GetAllJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllJobsResponse(rsp)
}

// CreateJobWithBodyWithResponse request with arbitrary body returning *CreateJobResponse
func (c *ClientWithResponses) CreateJobWithBodyWithResponse(ctx context.Context, params *CreateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJobWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

func (c *ClientWithResponses) CreateJobWithResponse(ctx context.Context, params *CreateJobParams, body CreateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJobResponse, error) {
	rsp, err := c.CreateJob(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJobResponse(rsp)
}

// GetAllJobsStatesWithResponse request returning *GetAllJobsStatesResponse
func (c *ClientWithResponses) GetAllJobsStatesWithResponse(ctx context.Context, params *GetAllJobsStatesParams, reqEditors ...RequestEditorFn) (*GetAllJobsStatesResponse, error) {
	rsp, err := c.GetAllJobsStates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllJobsStatesResponse(rsp)
}

// DeleteJobWithResponse request returning *DeleteJobResponse
func (c *ClientWithResponses) DeleteJobWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error) {
	rsp, err := c.DeleteJob(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, id openapi_types.UUID, params *GetJobParams, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// UpdateJobWithBodyWithResponse request with arbitrary body returning *UpdateJobResponse
func (c *ClientWithResponses) UpdateJobWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJobWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateJobWithResponse(ctx context.Context, id openapi_types.UUID, params *UpdateJobParams, body UpdateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJobResponse, error) {
	rsp, err := c.UpdateJob(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJobResponse(rsp)
}

// DisableJobWithResponse request returning *DisableJobResponse
func (c *ClientWithResponses) DisableJobWithResponse(ctx context.Context, id openapi_types.UUID, params *DisableJobParams, reqEditors ...RequestEditorFn) (*DisableJobResponse, error) {
	rsp, err := c.DisableJob(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableJobResponse(rsp)
}

// EnableJobWithResponse request returning *EnableJobResponse
func (c *ClientWithResponses) EnableJobWithResponse(ctx context.Context, id openapi_types.UUID, params *EnableJobParams, reqEditors ...RequestEditorFn) (*EnableJobResponse, error) {
	rsp, err := c.EnableJob(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableJobResponse(rsp)
}

// StartJobWithBodyWithResponse request with arbitrary body returning *StartJobResponse
func (c *ClientWithResponses) StartJobWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *StartJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartJobResponse, error) {
	rsp, err := c.StartJobWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartJobResponse(rsp)
}

func (c *ClientWithResponses) StartJobWithResponse(ctx context.Context, id openapi_types.UUID, params *StartJobParams, body StartJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StartJobResponse, error) {
	rsp, err := c.StartJob(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartJobResponse(rsp)
}

// StopJobWithBodyWithResponse request with arbitrary body returning *StopJobResponse
func (c *ClientWithResponses) StopJobWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *StopJobParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StopJobResponse, error) {
	rsp, err := c.StopJobWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopJobResponse(rsp)
}

func (c *ClientWithResponses) StopJobWithResponse(ctx context.Context, id openapi_types.UUID, params *StopJobParams, body StopJobJSONRequestBody, reqEditors ...RequestEditorFn) (*StopJobResponse, error) {
	rsp, err := c.StopJob(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopJobResponse(rsp)
}

// GetAllObjectRestorePointsWithResponse request returning *GetAllObjectRestorePointsResponse
func (c *ClientWithResponses) GetAllObjectRestorePointsWithResponse(ctx context.Context, params *GetAllObjectRestorePointsParams, reqEditors ...RequestEditorFn) (*GetAllObjectRestorePointsResponse, error) {
	rsp, err := c.GetAllObjectRestorePoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllObjectRestorePointsResponse(rsp)
}

// GetObjectRestorePointWithResponse request returning *GetObjectRestorePointResponse
func (c *ClientWithResponses) GetObjectRestorePointWithResponse(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointParams, reqEditors ...RequestEditorFn) (*GetObjectRestorePointResponse, error) {
	rsp, err := c.GetObjectRestorePoint(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectRestorePointResponse(rsp)
}

// GetObjectRestorePointDisksWithResponse request returning *GetObjectRestorePointDisksResponse
func (c *ClientWithResponses) GetObjectRestorePointDisksWithResponse(ctx context.Context, id openapi_types.UUID, params *GetObjectRestorePointDisksParams, reqEditors ...RequestEditorFn) (*GetObjectRestorePointDisksResponse, error) {
	rsp, err := c.GetObjectRestorePointDisks(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectRestorePointDisksResponse(rsp)
}

// InstantRecoveryVmwareFcdMountWithBodyWithResponse request with arbitrary body returning *InstantRecoveryVmwareFcdMountResponse
func (c *ClientWithResponses) InstantRecoveryVmwareFcdMountWithBodyWithResponse(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMountResponse, error) {
	rsp, err := c.InstantRecoveryVmwareFcdMountWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstantRecoveryVmwareFcdMountResponse(rsp)
}

func (c *ClientWithResponses) InstantRecoveryVmwareFcdMountWithResponse(ctx context.Context, params *InstantRecoveryVmwareFcdMountParams, body InstantRecoveryVmwareFcdMountJSONRequestBody, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMountResponse, error) {
	rsp, err := c.InstantRecoveryVmwareFcdMount(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstantRecoveryVmwareFcdMountResponse(rsp)
}

// GetVmwareFcdInstantRecoveryMountModelWithResponse request returning *GetVmwareFcdInstantRecoveryMountModelResponse
func (c *ClientWithResponses) GetVmwareFcdInstantRecoveryMountModelWithResponse(ctx context.Context, mountId openapi_types.UUID, params *GetVmwareFcdInstantRecoveryMountModelParams, reqEditors ...RequestEditorFn) (*GetVmwareFcdInstantRecoveryMountModelResponse, error) {
	rsp, err := c.GetVmwareFcdInstantRecoveryMountModel(ctx, mountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVmwareFcdInstantRecoveryMountModelResponse(rsp)
}

// InstantRecoveryVmwareFcdDismountWithResponse request returning *InstantRecoveryVmwareFcdDismountResponse
func (c *ClientWithResponses) InstantRecoveryVmwareFcdDismountWithResponse(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdDismountParams, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdDismountResponse, error) {
	rsp, err := c.InstantRecoveryVmwareFcdDismount(ctx, mountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstantRecoveryVmwareFcdDismountResponse(rsp)
}

// InstantRecoveryVmwareFcdMigrateWithBodyWithResponse request with arbitrary body returning *InstantRecoveryVmwareFcdMigrateResponse
func (c *ClientWithResponses) InstantRecoveryVmwareFcdMigrateWithBodyWithResponse(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMigrateResponse, error) {
	rsp, err := c.InstantRecoveryVmwareFcdMigrateWithBody(ctx, mountId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstantRecoveryVmwareFcdMigrateResponse(rsp)
}

func (c *ClientWithResponses) InstantRecoveryVmwareFcdMigrateWithResponse(ctx context.Context, mountId openapi_types.UUID, params *InstantRecoveryVmwareFcdMigrateParams, body InstantRecoveryVmwareFcdMigrateJSONRequestBody, reqEditors ...RequestEditorFn) (*InstantRecoveryVmwareFcdMigrateResponse, error) {
	rsp, err := c.InstantRecoveryVmwareFcdMigrate(ctx, mountId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstantRecoveryVmwareFcdMigrateResponse(rsp)
}

// GetServerCertificateWithResponse request returning *GetServerCertificateResponse
func (c *ClientWithResponses) GetServerCertificateWithResponse(ctx context.Context, params *GetServerCertificateParams, reqEditors ...RequestEditorFn) (*GetServerCertificateResponse, error) {
	rsp, err := c.GetServerCertificate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerCertificateResponse(rsp)
}

// GetServerTimeWithResponse request returning *GetServerTimeResponse
func (c *ClientWithResponses) GetServerTimeWithResponse(ctx context.Context, params *GetServerTimeParams, reqEditors ...RequestEditorFn) (*GetServerTimeResponse, error) {
	rsp, err := c.GetServerTime(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTimeResponse(rsp)
}

// GetAllServicesWithResponse request returning *GetAllServicesResponse
func (c *ClientWithResponses) GetAllServicesWithResponse(ctx context.Context, params *GetAllServicesParams, reqEditors ...RequestEditorFn) (*GetAllServicesResponse, error) {
	rsp, err := c.GetAllServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServicesResponse(rsp)
}

// GetAllSessionsWithResponse request returning *GetAllSessionsResponse
func (c *ClientWithResponses) GetAllSessionsWithResponse(ctx context.Context, params *GetAllSessionsParams, reqEditors ...RequestEditorFn) (*GetAllSessionsResponse, error) {
	rsp, err := c.GetAllSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSessionsResponse(rsp)
}

// GetSessionWithResponse request returning *GetSessionResponse
func (c *ClientWithResponses) GetSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSessionParams, reqEditors ...RequestEditorFn) (*GetSessionResponse, error) {
	rsp, err := c.GetSession(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionResponse(rsp)
}

// GetSessionLogsWithResponse request returning *GetSessionLogsResponse
func (c *ClientWithResponses) GetSessionLogsWithResponse(ctx context.Context, id openapi_types.UUID, params *GetSessionLogsParams, reqEditors ...RequestEditorFn) (*GetSessionLogsResponse, error) {
	rsp, err := c.GetSessionLogs(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionLogsResponse(rsp)
}

// StopSessionWithResponse request returning *StopSessionResponse
func (c *ClientWithResponses) StopSessionWithResponse(ctx context.Context, id openapi_types.UUID, params *StopSessionParams, reqEditors ...RequestEditorFn) (*StopSessionResponse, error) {
	rsp, err := c.StopSession(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopSessionResponse(rsp)
}

// GetAllTrafficRulesWithResponse request returning *GetAllTrafficRulesResponse
func (c *ClientWithResponses) GetAllTrafficRulesWithResponse(ctx context.Context, params *GetAllTrafficRulesParams, reqEditors ...RequestEditorFn) (*GetAllTrafficRulesResponse, error) {
	rsp, err := c.GetAllTrafficRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTrafficRulesResponse(rsp)
}

// UpdateTrafficRulesWithBodyWithResponse request with arbitrary body returning *UpdateTrafficRulesResponse
func (c *ClientWithResponses) UpdateTrafficRulesWithBodyWithResponse(ctx context.Context, params *UpdateTrafficRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTrafficRulesResponse, error) {
	rsp, err := c.UpdateTrafficRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTrafficRulesResponse(rsp)
}

func (c *ClientWithResponses) UpdateTrafficRulesWithResponse(ctx context.Context, params *UpdateTrafficRulesParams, body UpdateTrafficRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTrafficRulesResponse, error) {
	rsp, err := c.UpdateTrafficRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTrafficRulesResponse(rsp)
}

// ParseCreateAuthorizationCodeResponse parses an HTTP response from a CreateAuthorizationCodeWithResponse call
func ParseCreateAuthorizationCodeResponse(rsp *http.Response) (*CreateAuthorizationCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAuthorizationCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizationCodeModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportCredentialsResponse parses an HTTP response from a ExportCredentialsWithResponse call
func ParseExportCredentialsResponse(rsp *http.Response) (*ExportCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsImportSpecCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportCredentialsResponse parses an HTTP response from a ImportCredentialsWithResponse call
func ParseImportCredentialsResponse(rsp *http.Response) (*ImportCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportEncryptionPasswordsResponse parses an HTTP response from a ExportEncryptionPasswordsWithResponse call
func ParseExportEncryptionPasswordsResponse(rsp *http.Response) (*ExportEncryptionPasswordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportEncryptionPasswordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncryptionPasswordImportSpecCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportEncryptionPasswordsResponse parses an HTTP response from a ImportEncryptionPasswordsWithResponse call
func ParseImportEncryptionPasswordsResponse(rsp *http.Response) (*ImportEncryptionPasswordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportEncryptionPasswordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportJobsResponse parses an HTTP response from a ExportJobsWithResponse call
func ParseExportJobsResponse(rsp *http.Response) (*ExportJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobImportSpecCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportJobsResponse parses an HTTP response from a ImportJobsWithResponse call
func ParseImportJobsResponse(rsp *http.Response) (*ImportJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportManagedServersResponse parses an HTTP response from a ExportManagedServersWithResponse call
func ParseExportManagedServersResponse(rsp *http.Response) (*ExportManagedServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportManagedServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManageServerImportSpecCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportManagedServersResponse parses an HTTP response from a ImportManagedServersWithResponse call
func ParseImportManagedServersResponse(rsp *http.Response) (*ImportManagedServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportManagedServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportProxiesResponse parses an HTTP response from a ExportProxiesWithResponse call
func ParseExportProxiesResponse(rsp *http.Response) (*ExportProxiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportProxiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyImportSpecCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportProxiesResponse parses an HTTP response from a ImportProxiesWithResponse call
func ParseImportProxiesResponse(rsp *http.Response) (*ImportProxiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportProxiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportRepositoriesResponse parses an HTTP response from a ExportRepositoriesWithResponse call
func ParseExportRepositoriesResponse(rsp *http.Response) (*ExportRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryImportSpecCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseImportRepositoriesResponse parses an HTTP response from a ImportRepositoriesWithResponse call
func ParseImportRepositoriesResponse(rsp *http.Response) (*ImportRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllAutomationSessionsResponse parses an HTTP response from a GetAllAutomationSessionsWithResponse call
func ParseGetAllAutomationSessionsResponse(rsp *http.Response) (*GetAllAutomationSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAutomationSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAutomationSessionResponse parses an HTTP response from a GetAutomationSessionWithResponse call
func ParseGetAutomationSessionResponse(rsp *http.Response) (*GetAutomationSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutomationSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAutomationSessionLogsResponse parses an HTTP response from a GetAutomationSessionLogsWithResponse call
func ParseGetAutomationSessionLogsResponse(rsp *http.Response) (*GetAutomationSessionLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutomationSessionLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLogResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopAutomationSessionResponse parses an HTTP response from a StopAutomationSessionWithResponse call
func ParseStopAutomationSessionResponse(rsp *http.Response) (*StopAutomationSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopAutomationSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllManagedServersResponse parses an HTTP response from a GetAllManagedServersWithResponse call
func ParseGetAllManagedServersResponse(rsp *http.Response) (*GetAllManagedServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllManagedServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedServersResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateManagedServerResponse parses an HTTP response from a CreateManagedServerWithResponse call
func ParseCreateManagedServerResponse(rsp *http.Response) (*CreateManagedServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManagedServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteManagedServerResponse parses an HTTP response from a DeleteManagedServerWithResponse call
func ParseDeleteManagedServerResponse(rsp *http.Response) (*DeleteManagedServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManagedServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetManagedServerResponse parses an HTTP response from a GetManagedServerWithResponse call
func ParseGetManagedServerResponse(rsp *http.Response) (*GetManagedServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManagedServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ManagedServerModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateManagedServerResponse parses an HTTP response from a UpdateManagedServerWithResponse call
func ParseUpdateManagedServerResponse(rsp *http.Response) (*UpdateManagedServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateManagedServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllProxiesResponse parses an HTTP response from a GetAllProxiesWithResponse call
func ParseGetAllProxiesResponse(rsp *http.Response) (*GetAllProxiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllProxiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxiesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateProxyResponse parses an HTTP response from a CreateProxyWithResponse call
func ParseCreateProxyResponse(rsp *http.Response) (*CreateProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProxyResponse parses an HTTP response from a DeleteProxyWithResponse call
func ParseDeleteProxyResponse(rsp *http.Response) (*DeleteProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Deleted
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProxyResponse parses an HTTP response from a GetProxyWithResponse call
func ParseGetProxyResponse(rsp *http.Response) (*GetProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProxyResponse parses an HTTP response from a UpdateProxyWithResponse call
func ParseUpdateProxyResponse(rsp *http.Response) (*UpdateProxyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProxyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllRepositoriesResponse parses an HTTP response from a GetAllRepositoriesWithResponse call
func ParseGetAllRepositoriesResponse(rsp *http.Response) (*GetAllRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoriesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateRepositoryResponse parses an HTTP response from a CreateRepositoryWithResponse call
func ParseCreateRepositoryResponse(rsp *http.Response) (*CreateRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllRepositoriesStatesResponse parses an HTTP response from a GetAllRepositoriesStatesWithResponse call
func ParseGetAllRepositoriesStatesResponse(rsp *http.Response) (*GetAllRepositoriesStatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRepositoriesStatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryStatesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryResponse parses an HTTP response from a DeleteRepositoryWithResponse call
func ParseDeleteRepositoryResponse(rsp *http.Response) (*DeleteRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRepositoryResponse parses an HTTP response from a GetRepositoryWithResponse call
func ParseGetRepositoryResponse(rsp *http.Response) (*GetRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRepositoryResponse parses an HTTP response from a UpdateRepositoryWithResponse call
func ParseUpdateRepositoryResponse(rsp *http.Response) (*UpdateRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllScaleOutRepositoriesResponse parses an HTTP response from a GetAllScaleOutRepositoriesWithResponse call
func ParseGetAllScaleOutRepositoriesResponse(rsp *http.Response) (*GetAllScaleOutRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllScaleOutRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScaleOutRepositoriesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetScaleOutRepositoryResponse parses an HTTP response from a GetScaleOutRepositoryWithResponse call
func ParseGetScaleOutRepositoryResponse(rsp *http.Response) (*GetScaleOutRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScaleOutRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScaleOutRepositoryModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDisableScaleOutExtentMaintenanceModeResponse parses an HTTP response from a DisableScaleOutExtentMaintenanceModeWithResponse call
func ParseDisableScaleOutExtentMaintenanceModeResponse(rsp *http.Response) (*DisableScaleOutExtentMaintenanceModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableScaleOutExtentMaintenanceModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEnableScaleOutExtentMaintenanceModeResponse parses an HTTP response from a EnableScaleOutExtentMaintenanceModeWithResponse call
func ParseEnableScaleOutExtentMaintenanceModeResponse(rsp *http.Response) (*EnableScaleOutExtentMaintenanceModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableScaleOutExtentMaintenanceModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllBackupObjectsResponse parses an HTTP response from a GetAllBackupObjectsWithResponse call
func ParseGetAllBackupObjectsResponse(rsp *http.Response) (*GetAllBackupObjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBackupObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupObjectsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupObjectResponse parses an HTTP response from a GetBackupObjectWithResponse call
func ParseGetBackupObjectResponse(rsp *http.Response) (*GetBackupObjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupObjectModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupObjectRestorePointsResponse parses an HTTP response from a GetBackupObjectRestorePointsWithResponse call
func ParseGetBackupObjectRestorePointsResponse(rsp *http.Response) (*GetBackupObjectRestorePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupObjectRestorePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectRestorePointsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllBackupsResponse parses an HTTP response from a GetAllBackupsWithResponse call
func ParseGetAllBackupsResponse(rsp *http.Response) (*GetAllBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupResponse parses an HTTP response from a GetBackupWithResponse call
func ParseGetBackupResponse(rsp *http.Response) (*GetBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackupObjectsResponse parses an HTTP response from a GetBackupObjectsWithResponse call
func ParseGetBackupObjectsResponse(rsp *http.Response) (*GetBackupObjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupObjectsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConfigBackupOptionsResponse parses an HTTP response from a GetConfigBackupOptionsWithResponse call
func ParseGetConfigBackupOptionsResponse(rsp *http.Response) (*GetConfigBackupOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigBackupOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigBackupModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateConfigBackupOptionsResponse parses an HTTP response from a UpdateConfigBackupOptionsWithResponse call
func ParseUpdateConfigBackupOptionsResponse(rsp *http.Response) (*UpdateConfigBackupOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigBackupOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigBackupModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartConfigBackupResponse parses an HTTP response from a StartConfigBackupWithResponse call
func ParseStartConfigBackupResponse(rsp *http.Response) (*StartConfigBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartConfigBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetConnectionCertificateResponse parses an HTTP response from a GetConnectionCertificateWithResponse call
func ParseGetConnectionCertificateResponse(rsp *http.Response) (*GetConnectionCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectionCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConnectionCertificateModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllCredsResponse parses an HTTP response from a GetAllCredsWithResponse call
func ParseGetAllCredsResponse(rsp *http.Response) (*GetAllCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCredsResponse parses an HTTP response from a CreateCredsWithResponse call
func ParseCreateCredsResponse(rsp *http.Response) (*CreateCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CredentialsModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCredsResponse parses an HTTP response from a DeleteCredsWithResponse call
func ParseDeleteCredsResponse(rsp *http.Response) (*DeleteCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCredsResponse parses an HTTP response from a GetCredsWithResponse call
func ParseGetCredsResponse(rsp *http.Response) (*GetCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCredsResponse parses an HTTP response from a UpdateCredsWithResponse call
func ParseUpdateCredsResponse(rsp *http.Response) (*UpdateCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseChangePasswordForCredsResponse parses an HTTP response from a ChangePasswordForCredsWithResponse call
func ParseChangePasswordForCredsResponse(rsp *http.Response) (*ChangePasswordForCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePasswordForCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseChangePrivateKeyForCredsResponse parses an HTTP response from a ChangePrivateKeyForCredsWithResponse call
func ParseChangePrivateKeyForCredsResponse(rsp *http.Response) (*ChangePrivateKeyForCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePrivateKeyForCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseChangeRootPasswordForCredsResponse parses an HTTP response from a ChangeRootPasswordForCredsWithResponse call
func ParseChangeRootPasswordForCredsResponse(rsp *http.Response) (*ChangeRootPasswordForCredsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeRootPasswordForCredsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllEncryptionPasswordsResponse parses an HTTP response from a GetAllEncryptionPasswordsWithResponse call
func ParseGetAllEncryptionPasswordsResponse(rsp *http.Response) (*GetAllEncryptionPasswordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllEncryptionPasswordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncryptionPasswordsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateEncryptionPasswordResponse parses an HTTP response from a CreateEncryptionPasswordWithResponse call
func ParseCreateEncryptionPasswordResponse(rsp *http.Response) (*CreateEncryptionPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEncryptionPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EncryptionPasswordModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteEncryptionPasswordResponse parses an HTTP response from a DeleteEncryptionPasswordWithResponse call
func ParseDeleteEncryptionPasswordResponse(rsp *http.Response) (*DeleteEncryptionPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEncryptionPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEncryptionPasswordResponse parses an HTTP response from a GetEncryptionPasswordWithResponse call
func ParseGetEncryptionPasswordResponse(rsp *http.Response) (*GetEncryptionPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEncryptionPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncryptionPasswordModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateEncryptionPasswordResponse parses an HTTP response from a UpdateEncryptionPasswordWithResponse call
func ParseUpdateEncryptionPasswordResponse(rsp *http.Response) (*UpdateEncryptionPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEncryptionPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncryptionPasswordModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGeneralOptionsResponse parses an HTTP response from a GetGeneralOptionsWithResponse call
func ParseGetGeneralOptionsResponse(rsp *http.Response) (*GetGeneralOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGeneralOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeneralOptionsModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGeneralOptionsResponse parses an HTTP response from a UpdateGeneralOptionsWithResponse call
func ParseUpdateGeneralOptionsResponse(rsp *http.Response) (*UpdateGeneralOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGeneralOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeneralOptionsModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllInventoryVmwareHostsResponse parses an HTTP response from a GetAllInventoryVmwareHostsWithResponse call
func ParseGetAllInventoryVmwareHostsResponse(rsp *http.Response) (*GetAllInventoryVmwareHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllInventoryVmwareHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ViRootsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVmwareHostObjectResponse parses an HTTP response from a GetVmwareHostObjectWithResponse call
func ParseGetVmwareHostObjectResponse(rsp *http.Response) (*GetVmwareHostObjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmwareHostObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VCenterInventoryResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllJobsResponse parses an HTTP response from a GetAllJobsWithResponse call
func ParseGetAllJobsResponse(rsp *http.Response) (*GetAllJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateJobResponse parses an HTTP response from a CreateJobWithResponse call
func ParseCreateJobResponse(rsp *http.Response) (*CreateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest JobModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllJobsStatesResponse parses an HTTP response from a GetAllJobsStatesWithResponse call
func ParseGetAllJobsStatesResponse(rsp *http.Response) (*GetAllJobsStatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllJobsStatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobStatesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteJobResponse parses an HTTP response from a DeleteJobWithResponse call
func ParseDeleteJobResponse(rsp *http.Response) (*DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest Deleted
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateJobResponse parses an HTTP response from a UpdateJobWithResponse call
func ParseUpdateJobResponse(rsp *http.Response) (*UpdateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDisableJobResponse parses an HTTP response from a DisableJobWithResponse call
func ParseDisableJobResponse(rsp *http.Response) (*DisableJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEnableJobResponse parses an HTTP response from a EnableJobWithResponse call
func ParseEnableJobResponse(rsp *http.Response) (*EnableJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStartJobResponse parses an HTTP response from a StartJobWithResponse call
func ParseStartJobResponse(rsp *http.Response) (*StartJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopJobResponse parses an HTTP response from a StopJobWithResponse call
func ParseStopJobResponse(rsp *http.Response) (*StopJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllObjectRestorePointsResponse parses an HTTP response from a GetAllObjectRestorePointsWithResponse call
func ParseGetAllObjectRestorePointsResponse(rsp *http.Response) (*GetAllObjectRestorePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllObjectRestorePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectRestorePointsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetObjectRestorePointResponse parses an HTTP response from a GetObjectRestorePointWithResponse call
func ParseGetObjectRestorePointResponse(rsp *http.Response) (*GetObjectRestorePointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectRestorePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectRestorePointModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetObjectRestorePointDisksResponse parses an HTTP response from a GetObjectRestorePointDisksWithResponse call
func ParseGetObjectRestorePointDisksResponse(rsp *http.Response) (*GetObjectRestorePointDisksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectRestorePointDisksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectRestorePointDisksResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInstantRecoveryVmwareFcdMountResponse parses an HTTP response from a InstantRecoveryVmwareFcdMountWithResponse call
func ParseInstantRecoveryVmwareFcdMountResponse(rsp *http.Response) (*InstantRecoveryVmwareFcdMountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstantRecoveryVmwareFcdMountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VmwareFcdInstantRecoveryMount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVmwareFcdInstantRecoveryMountModelResponse parses an HTTP response from a GetVmwareFcdInstantRecoveryMountModelWithResponse call
func ParseGetVmwareFcdInstantRecoveryMountModelResponse(rsp *http.Response) (*GetVmwareFcdInstantRecoveryMountModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVmwareFcdInstantRecoveryMountModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VmwareFcdInstantRecoveryMount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInstantRecoveryVmwareFcdDismountResponse parses an HTTP response from a InstantRecoveryVmwareFcdDismountWithResponse call
func ParseInstantRecoveryVmwareFcdDismountResponse(rsp *http.Response) (*InstantRecoveryVmwareFcdDismountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstantRecoveryVmwareFcdDismountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VmwareFcdInstantRecoveryMount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseInstantRecoveryVmwareFcdMigrateResponse parses an HTTP response from a InstantRecoveryVmwareFcdMigrateWithResponse call
func ParseInstantRecoveryVmwareFcdMigrateResponse(rsp *http.Response) (*InstantRecoveryVmwareFcdMigrateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstantRecoveryVmwareFcdMigrateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VmwareFcdInstantRecoveryMount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetServerCertificateResponse parses an HTTP response from a GetServerCertificateWithResponse call
func ParseGetServerCertificateResponse(rsp *http.Response) (*GetServerCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetServerTimeResponse parses an HTTP response from a GetServerTimeWithResponse call
func ParseGetServerTimeResponse(rsp *http.Response) (*GetServerTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTimeModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllServicesResponse parses an HTTP response from a GetAllServicesWithResponse call
func ParseGetAllServicesResponse(rsp *http.Response) (*GetAllServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServicesResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllSessionsResponse parses an HTTP response from a GetAllSessionsWithResponse call
func ParseGetAllSessionsResponse(rsp *http.Response) (*GetAllSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionsResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSessionResponse parses an HTTP response from a GetSessionWithResponse call
func ParseGetSessionResponse(rsp *http.Response) (*GetSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSessionLogsResponse parses an HTTP response from a GetSessionLogsWithResponse call
func ParseGetSessionLogsResponse(rsp *http.Response) (*GetSessionLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionLogResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStopSessionResponse parses an HTTP response from a StopSessionWithResponse call
func ParseStopSessionResponse(rsp *http.Response) (*StopSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptySuccessResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllTrafficRulesResponse parses an HTTP response from a GetAllTrafficRulesWithResponse call
func ParseGetAllTrafficRulesResponse(rsp *http.Response) (*GetAllTrafficRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTrafficRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalNetworkTrafficRulesModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTrafficRulesResponse parses an HTTP response from a UpdateTrafficRulesWithResponse call
func ParseUpdateTrafficRulesResponse(rsp *http.Response) (*UpdateTrafficRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTrafficRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GlobalNetworkTrafficRulesModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
